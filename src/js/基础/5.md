---
date: 2022-04-20
category:
  - js初级
tag:
  - 正则表达式
---

# js正则表达式简介

## 简介

正则表达式(Regular Expression) 是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个规则字符串，这个规则字符串用来表达对字符串的一种过滤逻辑。

可以使用字面量形式或者new的方式来创建正则表达式

```js
// 使用直接字面量创建 ，推荐使用，性能更好，注意这里pattern不能为空，不然以为是注释
var exp1 = /\d/g

//使用RegExp对象创建
var exp2 = new RegExp('\d', 'g');
```

模式中使用的所有元字符都建议在之前加\转义，正则表达式中的元字符包括：

```text
( [ { \ ^ $ | ) ? * + . ] }
```


## 匹配模式

修饰符表示正则表达式的匹配模式

|   修饰符   |  描述 |
| ---- | ---- |
| i | 执行对大小写不敏感的匹配 |
| g | 执行全局匹配，查找所有匹配而非在找到第一个匹配后停止 |
| m | 执行多行匹配，会改变^和$的行为 |
| u | 可以匹配4字节的unicode编码 |
| s | dotAll模式, `.`可以匹配换行符 |

加了u修饰符，会正确处理大于\uFFFF的unicode，比如4字节的🐪 \uD83D\uDC2A

```js
/^\uD83D/.test('\uD83D\uDC2A') //true
/^\uD83D/u.test('\uD83D\uDC2A') //true
```

默认情况下，`.`可以匹配任意字符，除了换行符，且`.`不能匹配Unicode字符，需要使用u选项启用Unicode模式才行。

ES2018引入了dotAll模式，通过s选项可以启用，这样，`.`就可以匹配换行符了。

```js
/foo.bar/.test('foo\nbar'); 				// false
/foo.bar/s.test('foo\nbar');        // true   
```

## 类

类使用`[]`来表达，用于查找某个范围内的字符

|   表达式   |  描述 |
| ---- | ---- |
| `[abc]` | 查找方括号之间的任何字符 |
| `[0-9]` | 查找任何从0至9的数字 |

还有一些预定义类方便我们使用：

|   预定义类   |  等价 | 描述 |
| ---- | ---- | ---- |
| `\s` | `[\t\n\x0B\f\r]` | 空格 |
| `\S` | `[^\t\n\x0B\f\r]` | 非空格 |
| `\d` | `[0-9]` | 数字 |
| `\D` | `[^0-9]` | 非数字 |
| `\w` | `[a-zA-Z_0-9]` | 单词字符(字母数字下划线) |
| `\W` | `[^a-zA-Z_0-9]` | 非单词字符 |
| `.` | `[^\r\n]` | 任意字符，除了回车与换行外所有字符 |
| `\f` | `\x0c \cL` | 匹配一个换页符 |
| `\n` | `\x0a \cJ` | 匹配一个换行符 |
| `\r` | `\x0d \cM` | 匹配一个回车符 |
| `\t` | `\x09 \cI` | 匹配一个制表符 |
| `\v` | `\x0b \cK` | 匹配一个垂直制表符 |
| `\xxx` |  | 查找以八进制数 xxx 规定的字符 |
| `\xdd` |  | 查找以十六进制数 dd 规定的字符 |
| `\uxxxx` |  | 查找以十六进制数 xxxx 规定的 Unicode 字符 |

## 量词

量词表示匹配多少个目标对象，精确匹配长度使用`{}`

|   量词   | 等价 | 描述 |
| ---- | ---- | ---- |
| n`*` | `{0,}` | 匹配零个或多个n |
| n`+` | `{1,}` | 匹配至少一个 n 的字符串 |
| n`?` | `{0,1}` | 匹配零个或一个n |
| `{n}` |  | 匹配n次 |
| `{n,m}` |  | 匹配n到m次 |
| `{n,}` |  | 至少匹配n次 |

## 边界

|   边界   | 描述 |
| ---- | ---- |
| `^` | 以xx开始，在类`[ ]`中表示非 | 
| `$` | 以xx结束 | 
| `\b` | 单词边界 | 
| `\B` | 非单词边界 |

`^`匹配字符串开始位置，也就是位置0，如果设置了 RegExp 对象的 Multiline 属性m，`^` 也匹配 '\n' 或 '\r' 之后的位置

`$`一般匹配字符串结束位置，如果设置了 RegExp 对象的 Multiline 属性m，`$` 也匹配 '\n' 或 '\r' 之前的位置

`\b`匹配一个单词边界，也就是指单词和空格间的位置，如 er`\b`可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'

`\B`匹配非单词边界。如 er`\B`能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'

## 分组

分组使用`()`作用是提取相匹配的字符串，使量词作用于分组 比如`hehe{3}`是把e匹配了3次而不是单词，如果希望作用于单词，可以使用分组`(hehe){3}`

### 或 |

分组中使用 | 可以达到或的效果 比如：T(oo|ii)m可以匹配 Toom 和 Tiim

```js
`abToomhaTiimmm`.replace(/T(oo|ii)m/g, '-')                // ab-ha-mm
```

### 反向引用

使用`()`后可以使用$1-$9等来匹配

```js
'2018-02-11'.replace(/(\d{4})\-(\d{2})\-(\d{2})/g, '$2/$3/$1')            //  02/11/2018
```

### 后向引用

\n 表示后向引用，\1是指在正则表达式中，从左往右数第1个( )中的内容；以此类推，\2表示第2个( )，\0表示整个表达式。

```js
//匹配日期格式，表达式中的\1代表重复(\-|\/|.)
var rgx = /\d{4}(\-|\/|.)\d{1,2}\1\d{1,2}/
rgx.test("2016-03-26")             // true
rgx.test("2016-03.26")             // false
rgx.test("2016.03.06")             // true
```

### 分组命名(ES9)

ES2018 之前的分组是通过数字命名的：

```js
const pattern = /(\d{4})-(\d{2})-(\d{2})/u;
const result = pattern.exec('2018-10-25');
console.log(result[0]); // 打印"2018-10-25"
console.log(result[1]); // 打印"2018"
console.log(result[2]); // 打印"10"
console.log(result[3]); // 打印"25"
```

现在可以通过指定分组的名称，增加代码可读性，便于维护：

```js
const pattern = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;
const result = pattern.exec('2018-10-25');
console.log(result.groups.year);         // 打印"2018"
console.log(result.groups.month);        // 打印"10"
console.log(result.groups.day);          // 打印"25"
```

分组命名还可以和String.prototype.replace方法结合：

```js
const reDate = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
const d = '2018-10-25';
const USADate = d.replace(reDate, '$<month>-$<day>-$<year>');
console.log(USADate);		// 10-25-2018
```

### 忽略分组

如果不希望捕获某些分组，在分组内加上`?:`即可 比如`(?:tom).(ok)`那么这里$1指的就是ok

### 前瞻

前瞻 Lookahead 是RegExp匹配到规则的时候，向后检查是否符合断言，后顾JS目前不支持 (ES2018已经支持)

|   名称   |  正则 | 描述 |
| ---- | ---- | ---- |
| 正向前瞻 | `(?= )` | 后面要有xx |
| 负向前瞻 | `(?!)` | 后面不能有xx |

```js
'1a2bc*456v8'.replace(/\w(?=\d)/g, '-')        //  1-2bc*--6-8    匹配后面是数字的单词字符
'1a2bc*456v8'.replace(/\w(?!\d)/g, '-')               //  -a---*45-v-    匹配后面不是数字的单词字符
 
const pattern1 = /\d+(?= dollars)/u;             // 正向前瞻，匹配字符串中紧跟着是dollars的数字
const result1 = pattern1.exec('42 dollars');
console.log(result1[0])                                    // 打印42
 
const pattern2 = /\d+(?! dollars)/u;           // 负向前瞻，匹配字符串中紧跟着的不是dollars的数字
const result2 = pattern2.exec('42 pesos');
console.log(result2[0]);                                     // 打印42
```

### 后顾

后顾 Lookbehind 是RegExp匹配到规则的时候，向前检查是否符合断言

|   名称   |  正则 | 描述 |
| ---- | ---- | ---- |
| 正向后顾 | `(?<= )` | 前面有xx |
| 负向后顾 | `(?<! )` | 前面面不能有xx |

```js
const pattern1 = /(?<=\$)\d+/u;           // 正向后顾，匹配字符串中前面是\$的数字
const result1 = pattern1.exec('$42');
console.log(result1[0]);             // 打印42 
 
const pattern2 = /(?<!\$)\d+/u;           // 负向后顾，匹配字符串中前面不是是\$的数字
const result2 = pattern2.exec('€42');
console.log(result2[0]);                 // 打印42
```

## 贪婪模式与非贪婪模式

正则表达式在匹配的时候默认会尽可能多的匹配，叫贪婪模式。通过在限定符后加?可以进行非贪婪匹配 比如\d{3,6}默认会匹配6个数字而不是3个，在量词{ }后加一个?就可以修改成非贪婪模式，匹配3次

```js
`12345678`.replace(/\d{3,6}/, '-')                // -78
`12345678`.replace(/\d{3,6}?/, '-')                // -45678
'abbbb'.replace(/ab+?/, '-')                //  -bbb
```

## 优先级

优先级从高到底：

- 转义 \

- 括号( )、(?: )`忽略分组`、(?= )`前瞻`、[ ]

- 字符和位置

- 或 |

## 常用属性与方法

## RegExp构造函数属性

RegExp构造函数上也包含一些属性，这些属性适用于作用域中所有的正则表达式，并且基于所执行的最近一次正则表达式操作而变化，这些属性分别有一个长属性名和短属性名

|   长属性名   |  短属性名 | 描述 |
| ---- | ---- | ---- |
| input | `$_` | 返回执行规范表述查找的字符串。只读 |
| lastMatch|	`$&`	|返回任何正则表达式搜索过程中的最后匹配的字符。只读|
|lastParen | $+ |	如果有的话，返回任何正则表达式查找过程中最后括的子(分组)匹配。只读 |
|leftContext|	$\ |	返回被查找的字符串中从字符串开始位置到最后匹配之前的位置之间的字符。只读 |
|rightContext| $' |	返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符。只读|

## RegExp实例上的属性

|   属性   |  描述 | 
| ---- | ---- |
|global|	是否全文搜索，默认false，对应修饰符的g，只读|
|ignoreCase|	是否大小写敏感，默认false，对应修饰符i，只读|
|multiline|	是否多行搜索，默认false，对应修饰符m，只读|
|flags|	返回修饰符，只读|
|lastIndex|	当前表达式匹配内容的最后一个字符的下一个位置|
|source|	正则表达式的文本字符串|

## 常用方法

### `RegExp.prototype.test(str)`

测试字符串参数中是否存在匹配正则表达式的字符串，使用.test的时候如果修饰符有g ，那么会正则会记住lastIndex并在下一次执行的时候从lastIndex处开始检测，如果只是为了测试是否符合正则，可以不用g或者每次都重新实例化正则表达式

```js
const reg=/\w/g
reg.test('a')                              //  true
reg.test('a')                              //  false
```

### `RegExp.prototype.exec(str)`

使用正则表达式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果

如果匹配失败，exec() 方法返回 null

如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的属性

- 数组索引0：匹配的全部字符串
- 数组索引1,2..n：括号中的分组捕获
- index：属性是匹配文本的第一个字符的位置
- input：存放被检索的字符串

要注意的是：

- exec()永远只返回一个匹配项（指匹配整个正则的）
- 如果设置了g修饰符，每次调用exec()会在字符串中继续查找新匹配项，不设置g修饰符，对一个字符串每次调用exec()永远只返回第一个匹配项。所以如果要匹配一个字符串中的所有需要匹配的地方，那么可以设置g修饰符，然后通过循环不断调用exec方法。

```js
//匹配所有ing结尾的单词
const str="Reading and Writing"
const pattern=/\b([a-zA-Z]+)ing\b/g
let matches
while(matches=pattern.exec(str)){
  console.log(matches.index +' '+ matches[0] + ' ' + matches[1]);
}
// 0 Reading Read
// 12 Writing Writ
```

### `String.prototype.search(reg)`

search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串 方法返回第一个匹配结果的index，查找不到返回-1 search() 方法不执行全局匹配，它将忽略修饰符g，并且总是从字符串的开始进行检索

### `String.prototype.split(reg)`

split() 方法一般用来分割字符串成数组，也可以传入正则表达式，使用正则可以避免一些传入字符串解决不了的问题

```js
'a1b2c3d4e'.split(/\d/)                   //  ["a", "b", "c", "d", "e"]
'a b   c'.split(' ')                        // ['a', 'b', '', '', 'c']   无法识别连续空格
'a b   c'.split(/\s*/)                      // ['a', 'b', 'c']
```

### `String.prototype.match(reg)`

match() 方法将检索字符串，以找到一个或多个与reg相匹配的文本，reg是否有修饰符g影响很大 返回值与RegExp.prototype.exec的返回类似，不过只返回匹配的字符串数组

```js
'cdbbdbsdbdbzddzdbbbd'.match(/d(b+)d/g)              //   ["dbbd", "dbd", "dbbbd"]
'cdbbdbsdbdbzddzdbbbd'.match(/d(b+)d/)             //   ["dbbd", "bb", index: 1, input: "cdbbdbsdbdbzddzdbbbd"]
```

如果修饰符有g则匹配出所有匹配的数组，如果不是，则出第一个匹配的字符串，以及相应的捕获内容

### `String.prototype. replace (reg, str | num | function)`

找到匹配并替换，传入string、number比较常见，这里传入回调function是比较高级的用法，这里可以参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0)

比如一个场景，把手机号的中间4位换成*

```js
function validateMobile(str) {
  return /^[1][0-9]{10}$/.test(str) &&
    str.replace(/(\d{3})(\d{4})(\d{4})/, (rs,$1,$2,$3) => `${$1}****${$3}`)
}
```

也可以不返回值，用回调来遍历，比如一个在面试中会遇到的问题：找出重复最多的字符

```js
let str = 'asss23sjdssskssa7lsssdkjsssdss'
 
const arr = str.split(/\s*/)              // 把字符串转换为数组
const str2 = arr.sort().join('')               // 首先进行排序，这样结果会把相同的字符放在一起，然后再转换为字符串
 
let value = ''
let index = 0
str2.replace(/(\w)\1*/g, function($0, $1) {         //匹配字符
  if (index < $0.length) {
    index = $0.length                   // index是出现次数
    value = $1                              // value是对应字符
  }
})
 
console.log(`最多的字符: ${value} ,重复的次数: ${index}`)          // s   17
```

## 常见表达式

### 常见检验数字的表达式

```text
- 数字：^[0-9]*$
- n位的数字：^\d{n}$
- 至少n位的数字：^\d{n,}$
- m-n位的数字：^\d{m,n}$
- 零和非零开头的数字：^(0|[1-9][0-9]*)$
- 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$
- 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$
- 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$
- 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$
- 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$
- 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$
- 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$
- 非负整数：^\d+$ 或 ^[1-9]\d*|0$
- 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
- 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
- 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$
- 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
- 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
- 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$
```

### 校检字符的表达式

```text
- 汉字：^[\u4e00-\u9fa5]{0,}$
- 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
- 长度为3-20的所有字符：^.{3,20}$
- 由26个英文字母组成的字符串：^[A-Za-z]+$
- 由26个大写英文字母组成的字符串：^[A-Z]+$
- 由26个小写英文字母组成的字符串：^[a-z]+$
- 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
- 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
- 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 
- 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$ 
- 可以输入含有^%&',;=?$\"等字符：\[^%&',;=?$\x22\]\+ 
- 禁止输入含有~的字符：[^~\x22]+
```

### 特殊需求表达式

```text
- Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
- 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
- InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$
- 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
- 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$
- 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}
- 身份证号(15位、18位数字)：^\d{15}|\d{18}$ 
- 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 
- 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 
- 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$
- 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 
日期格式：^\d{4}-\d{1,2}-\d{1,2}
- 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$
- 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$
钱的输入格式： 
  1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$ 
  2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 
  3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 
  4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 
  5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$ 
  6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 
  7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 
  8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 
  备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 
- xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
- 中文字符的正则表达式：[\u4e00-\u9fa5] 
- 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 
- 空白行的正则表达式：\n\s*\r (可以用来删除空白行) 
- HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 
- 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 
- 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)
- 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)
- IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)
- IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))
```

