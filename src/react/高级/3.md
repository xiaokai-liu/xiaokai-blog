---
date: 2022-07-06
category:
  - react
tag:
  - react源码
---

# React核心源码解析2

## diff算法

在render阶段，对于update的组件，他会将当前组件与该组件在上次更新时对应的Fiber节点比较（也就是俗称的Diff算法），将比较的结果生成新Fiber节点。

官网对diff算法的介绍：https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm

1. 不同类型的元素：React拆卸原有的树，生成新的树

```jsx
<div>
 <Counter />
</div>
<span>
 <Counter />
</span>
```

a. 卸载时：
ⅰ. DOM节点销毁；
ⅱ. 执行componentWilUnmount()；
b. 新建时：
ⅰ. 执行UNSAFE_componentWillMount()，然后执行componentDidMount()；

2. 同一类型的元素

```html
<div className="before" title="stuff" />
<div className="after" title="stuff" />

<div style={{color: 'red', fontWeight: 'bold'}} />
<div style={{color: 'green', fontWeight: 'bold'}}></>
```

a. 保留DOM节点，仅对比更新有改变的属性

3. 对比同类型的组件元素：

a. 组件更新时，组件实例保持不变，保证state不变，更新组件的props以保证与新的元素一致，调用UNSAFE_componentWillReceiveProps()、UNSAFE_componentWillUpdate() 以及componentDidUpdate() 方法；

b. 调用render，执行diff
ⅰ. React 同时遍历两个子元素的列表；当产生差异时，生成一个 mutation

1. 在子元素列表结尾新增
2. 在子元素列表头部新增

```jsx
<ul>
 <li>first</li>
 <li>second</li>
</ul>
<ul>
 <li>first</li>
 <li>second</li>
 <li>third</li> // 只需要新增元素即可
</ul>
```

```jsx
<ul>
 <li>Duke</li>
 <li>Villanova</li>
</ul>
// 销毁子元素列表，新建新的子元素列表，有性能问题
<ul>
 <li>Connecticut</li>
 <li>Duke</li>
 <li>Villanova</li>
</ul>
```

c. 使用keys：直接比较key值定位，所以key传index也会有性能问题

```jsx
<ul>
 <li key="2015">Duke</li>
 <li key="2016">Villanova</li>
</ul>
<ul>
 <li key="2014">Connecticut</li>
 <li key="2015">Duke</li>
 <li key="2016">Villanova</li>
</ul>
```

d. 官网总结：

:::tip
1. 该算法不会尝试匹配不同组件类型的子树。如果你发现你在两种不同类型的组件中切换，但输出非常相似的内容，建议把它们改成同一类型。在实践中，我们没有遇到这类问题；
2. Key 应该具有稳定，可预测，以及列表内唯一的特质。不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失；
:::

结合render和commit阶段，一个DOM节点最多有4个节点与之相关：

1. current Fiber。如果该DOM节点已在页面中，current Fiber代表该DOM节点对应的Fiber节点；
2. workInProgress Fiber。如果该DOM节点将在本次更新中渲染到页面中，workInProgress Fiber代表该DOM节点对应的Fiber节点；
3. DOM节点本身；
4. JSX对象。即ClassComponent的render方法的返回结果，或FunctionComponent的调用结果。JSX对象中包含描述DOM节点的信息；

diff算法：对比1 4 生成2

### Diff的瓶颈及处理方法

diff操作本身也会带来性能损耗，React文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 O(n^3)，其中n是树中元素的数量；如果在React中使用了该算法，那么展示1000个元素所需要执行的计算量将在⼗亿的量级范围。这个开销实在是太过高昂；

为了降低算法复杂度，React的diff会预设三个限制：

1. 只对同级元素进行diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React会忽略；
2. 两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点；
3. 开发者可以通过 key prop来暗示哪些子元素在不同的渲染下能保持稳定；

### Diff是如何实现的

Diff的入口函数是reconcileChildFibers：会根据newChild（即JSX对象）类型调用不同的处理函数

地址：
https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1280

```js
// 根据newChild类型选择不同diff函数处理
function reconcileChildFibers(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    newChild: any,
): Fiber | null {
    const isObject = typeof newChild === 'object' && newChild !== null;
    if (isObject) {
        // object类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE
        switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
            // 调用 reconcileSingleElement 处理
            // // ...省略其他case
        }
    }
    if (typeof newChild === 'string' || typeof newChild === 'number') {
    // 调用 reconcileSingleTextNode 处理
    // ...省略
    }
    if (isArray(newChild)) {
    // 调用 reconcileChildrenArray 处理
    // ...省略
    }
    // 一些其他情况调用处理函数
    // ...省略
    // 以上都没有命中，删除节点
    return deleteRemainingChildren(returnFiber, currentFirstChild);
}
```

根据同级的节点数量将Diff分为两类：

1. 当newChild类型为object、number、string，代表同级只有一个节点
2. 当newChild类型为Array，同级有多个节点

### 单节点diff

以类型为object为例，执行reconcileSingleElement

```js
const isObject = typeof newChild === 'object' && newChild !== null;
 if (isObject) {
    // 对象类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE
    switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
        // 调用 reconcileSingleElement 处理
        // ...其他case
    }
 }
```

地址：
https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1141

执行流程：

![single](../images/single.png)

```js
function reconcileSingleElement(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    element: ReactElement
): Fiber {
    const key = element.key;
    let child = currentFirstChild;

    // 首先判断是否存在对应DOM节点
    while (child !== null) {
        // 上一次更新存在DOM节点，接下来判断是否可复用
        // 首先比较key是否相同
        if (child.key === key) {
            // key相同，接下来比较type是否相同
            switch (child.tag) {
                // ...省略case

                default: {
                    if (child.elementType === element.type) {
                        // type相同则表示可以复用
                        // 返回复用的fiber
                        return existing;
                    }

                    // type不同则跳出switch
                    break;
                }
            }
            // 代码执行到这里代表：key相同但是type不同
            // 将该fiber及其兄弟fiber标记为删除
            deleteRemainingChildren(returnFiber, child);
            break;
        } else {
        // key不同，将该fiber标记为删除
        deleteChild(returnFiber, child);
        }
        child = child.sibling;
    }
    // 创建新Fiber，并返回 ...省略
}
```

1. 先判断key是否相同，如果key相同则判断type是否相同，只有都相同时一个DOM节点才能复用；
2. 删除逻辑：
a. 当child !== null且key相同且type不同时执行deleteRemainingChildren将child及其兄弟fiber都标记删除；
b. 当child !== null且key不同时仅将child标记删除；

```js
// current fiber
ul > li li li
// JSX
ul > p
```

需要根据第一个li与p是否相同判断
1. key相同type不同，当前fiber和后续sibling fiber删除；
2. key不同，type也不同，删除当前fiber，前往下一个sibling fiber；

```jsx
// 更新前
<div>a</div>
// 更新后
<p>a</p>
// key为null，一致，但type不同，不能复用
// 更新前
<div key="xxx">a</div>
// 更新后
<div key="ooo">a</div>
// key不同，不需要看type，不能复用
// 更新前
<div key="xxx">a</div>
// 更新后
<p key="ooo"a</p>
// key不同，不需要看type，不能复用
// 更新前
<div key="xxx">a</div>
// 更新后
<div key="xxx">b</div>
// key type都相同，props中children不同，更新子元素
```

### 多节点diff

对于多节点的functionComponent，reconcileChildFibers的newChild参数类型为Array，执行reconcileChildrenArray

```js
if (isArray(newChild)) {
 // 调用 reconcileChildrenArray 处理
 // ...省略
}
```

同级多个节点的diff，归纳为：
1. 节点更新
2. 节点新增或减少
3. 节点位置变化

```js
// 更新前
<ul>
 <li key="0" className="before">0<li>
 <li key="1">1<li>
</ul>
// 更新后 情况1 —— 节点属性变化
<ul>
 <li key="0" className="after">0<li>
 <li key="1">1<li>
</ul>
// 更新后 情况2 —— 节点类型更新
<ul>
 <div key="0">0</div>
 <li key="1">1<li>
</ul>
```

```js
// 更新前
<ul>
 <li key="0">0<li>
 <li key="1">1<li>
</ul>
// 更新后 情况1 —— 新增节点
<ul>
 <li key="0">0<li>
 <li key="1">1<li>
 <li key="2">2<li>
</ul>
// 更新后 情况2 —— 删除节点
<ul>
 <li key="1">1<li>
</ul>
```

```js
// 更新前
<ul>
 <li key="0">0<li>
 <li key="1">1<li>
</ul>
// 更新后
<ul>
 <li key="1">1<li>
 <li key="0">0<li>
</ul>
```

#### diff思路

1. 针对节点更新

a. 新增：执行新增逻辑
b. 删除：执行删除逻辑
c. 更新：执行更新逻辑

前提：操作优先级一样，但实际开发中，React团队发现，相较于新增和删除，更新组件发生的频率更高。所以Diff会优先判断当前节点是否属于更新

Q：同级比较能否使用双指针算法提高遍历速度？

不可以
待更新对象为JSX，其中newChildren为数组格式，但current fiber 是链表格式，同级的fiber节点是由sibling指针形成的单链表，不支持双指针遍历；

:::tip
newChildren[0]与fiber比较，newChildren[1]与fiber.sibling比较,无法针对数组和链表进行比较，所以不可行
:::

react团队提供的思路：2轮遍历

1. 处理 更新 的节点；
2. 处理非 更新 的节点；

#### 第一轮遍历

地址：
https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L818

1. let i = 0，遍历newChildren，将newChildren[i]与oldFiber比较，判断DOM节点是否可复用；
2. 如果可复用，i++，继续比较newChildren[i]与oldFiber.sibling，可以复用则继续遍历；
3. 如果不可复用，分两种情况：
a. key不同导致不可复用，立即跳出整个遍历，第一轮遍历结束；
b. key相同type不同导致不可复用，会将oldFiber标记为DELETION，并继续遍历；
4. 如果newChildren遍历完（即 i === newChildren.length - 1 ）或者oldFiber遍历完（即oldFiber.sibling === null），跳出遍历，第一轮遍历结束；

其中，3 4可以完成当前遍历

3：此时newChildren没有遍历完，oldFiber也没有遍历完

```js
// 更新前
<li key="0">0</li>
<li key="1">1</li>
<li key="2">2</li>

// 更新后
<li key="0">0</li>
<li key="2">1</li>
<li key="1">2</li>
// 第一个节点可复用，遍历到key === 2的节点发现key改变，不可复用
// 跳出遍历，等待第二轮遍历处理
// oldFiber: key === 1、key === 2未遍历
// newChildren剩下key === 2、key === 1未遍历
```

4：可能newChildren遍历完，或oldFiber遍历完，或他们同时遍历完

```js
// 更新前
<li key="0" className="a">0</li>
<li key="1" className="b">1</li>

// 更新后 情况1 —— newChildren与oldFiber都遍历完
<li key="0" className="aa">0</li>
<li key="1" className="bb">1</li>

// 更新后 情况2 —— newChildren没遍历完，oldFiber遍历完
// newChildren剩下 key==="2" 未遍历
<li key="0" className="aa">0</li>
<li key="1" className="bb">1</li>
<li key="2" className="cc">2</li>

// 更新后 情况3 —— newChildren遍历完，oldFiber没遍历完
// oldFiber剩下 key==="1" 未遍历
<li key="0" className="aa">0</li>
```

#### 第二轮遍历

1. newChildren 和 oldFiber 同时遍历完

不需要第二轮的遍历，直接进行 update，diff结束；

2. newChildren没遍历完，oldFiber遍历完

已有的DOM节点都对比结束，这时还有新加入的节点，意味着本次更新有新节点插入，我们只需要遍历剩下的newChildren为生成的workInProgress fiber依次标记Placement；

地址：
https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L869

3. newChildren遍历完，oldFiber没遍历完

本次更新比之前的节点数量少，有节点被删除了。所以需要遍历剩下的oldFiber，依次标记Deletion；

4. newChildren与oldFiber都没遍历完

意味着有节点更新了位置

#### 如何处理更新后的节点

由于有节点改变了位置，所以不能再用位置索引i对比前后的节点，那么如何才能将同一个节点在两次更新中对应上呢--key

为了快速的找到key对应的oldFiber，我们将所有还未处理的oldFiber存入以key为key，oldFiber为value的Map中

```js
const existingChildren = mapRemainingChildren(returnFiber, oldFiber);
```

接下来遍历剩余的newChildren，通过newChildren[i].key就能在existingChildren中找到key相同的oldFiber

#### 标记节点是否移动

如何判断节点是否移动？参照物是什么？

我们的参照物是：最后一个可复用的节点在oldFiber中的位置索引（用变量lastPlacedIndex表示）。

本次更新中节点是按newChildren的顺序排列。在遍历newChildren过程中，每个遍历到的可复用节点一定是当前遍历到的所有可复用节点中最靠右的那个，即一定在lastPlacedIndex对应的可复用的节点在本次更新中位置的后面；

所以只需要比较遍历到的可复用节点在上次更新时是否也在lastPlacedIndex对应的oldFiber后面，就能知道两次更新中这两个节点的相对位置改变没有；

我们用变量oldIndex表示遍历到的可复用节点在oldFiber中的位置索引。如果oldIndex < lastPlacedIndex，代表本次更新该节点需要向右移动；

lastPlacedIndex初始为0，每遍历一个可复用的节点，如果oldIndex >= lastPlacedIndex，则lastPlacedIndex = oldIndex；

#### demo

每个字母代表一个节点，字母的值代表节点的key

demo 1

```text
// 之前
abcd
// 之后
acdb
===第一轮遍历开始===
a（之后）vs a（之前）
key不变，可复用
此时 a 对应的oldFiber（之前的a）在之前的数组（abcd）中索引为0
所以 lastPlacedIndex = 0;
继续第一轮遍历...
c（之后）vs b（之前）
key改变，不能复用，跳出第一轮遍历
此时 lastPlacedIndex === 0;
===第一轮遍历结束===
===第二轮遍历开始===
newChildren === cdb，没用完，不需要执行删除旧节点
oldFiber === bcd，没用完，不需要执行插入新节点
将剩余oldFiber（bcd）保存为map
// 当前oldFiber：bcd
// 当前newChildren：cdb
继续遍历剩余newChildren
key === c 在 oldFiber中存在
const oldIndex = c（之前）.index;
此时 oldIndex === 2; // 之前节点为 abcd，所以c.index === 2
比较 oldIndex 与 lastPlacedIndex;
如果 oldIndex >= lastPlacedIndex 代表该可复用节点不需要移动
并将 lastPlacedIndex = oldIndex;
如果 oldIndex < lastplacedIndex 该可复用节点之前插入的位置索引小于这次更新需要插入
的位置索引，代表该节点需要向右移动
在例子中，oldIndex 2 > lastPlacedIndex 0，
则 lastPlacedIndex = 2;
c节点位置不变
继续遍历剩余newChildren

// 当前oldFiber：bd
// 当前newChildren：db
key === d 在 oldFiber中存在
const oldIndex = d（之前）.index;
oldIndex 3 > lastPlacedIndex 2 // 之前节点为 abcd，所以d.index === 3
则 lastPlacedIndex = 3;
d节点位置不变
继续遍历剩余newChildren
// 当前oldFiber：b
// 当前newChildren：b
key === b 在 oldFiber中存在
const oldIndex = b（之前）.index;
oldIndex 1 < lastPlacedIndex 3 // 之前节点为 abcd，所以b.index === 1
则 b节点需要向右移动
===第二轮遍历结束===
最终acd 3个节点都没有移动，b节点被标记为移动
```

demo 2

```text
// 之前
abcd
// 之后
dabc
===第一轮遍历开始===
d（之后）vs a（之前）
key改变，不能复用，跳出遍历
===第一轮遍历结束===
===第二轮遍历开始===
newChildren === dabc，没用完，不需要执行删除旧节点
oldFiber === abcd，没用完，不需要执行插入新节点
将剩余oldFiber（abcd）保存为map
继续遍历剩余newChildren
// 当前oldFiber：abcd
// 当前newChildren dabc
key === d 在 oldFiber中存在
const oldIndex = d（之前）.index;
此时 oldIndex === 3; // 之前节点为 abcd，所以d.index === 3
比较 oldIndex 与 lastPlacedIndex;
oldIndex 3 > lastPlacedIndex 0
则 lastPlacedIndex = 3;
d节点位置不变
继续遍历剩余newChildren
// 当前oldFiber：abc
// 当前newChildren abc
key === a 在 oldFiber中存在
const oldIndex = a（之前）.index; // 之前节点为 abcd，所以a.index === 0
此时 oldIndex === 0;
比较 oldIndex 与 lastPlacedIndex;
oldIndex 0 < lastPlacedIndex 3
则 a节点需要向右移动
继续遍历剩余newChildren
// 当前oldFiber：bc
// 当前newChildren bc
key === b 在 oldFiber中存在
const oldIndex = b（之前）.index; // 之前节点为 abcd，所以b.index === 1
此时 oldIndex === 1;
比较 oldIndex 与 lastPlacedIndex;
oldIndex 1 < lastPlacedIndex 3
则 b节点需要向右移动
继续遍历剩余newChildren
// 当前oldFiber：c
// 当前newChildren c
key === c 在 oldFiber中存在
const oldIndex = c（之前）.index; // 之前节点为 abcd，所以c.index === 2
此时 oldIndex === 2;
比较 oldIndex 与 lastPlacedIndex;
oldIndex 2 < lastPlacedIndex 3
则 c节点需要向右移动
===第二轮遍历结束===
```

所以，尽量减少节点从后面移动到前面的操作
1. abcd -> acdb：b移动到最右边
2. abcd -> dabc：abc移动到最右边

## 状态更新

### 概览

梳理下几个关键的节点：
1. render阶段的开始
开始于 performSyncWorkOnRoot 或 performConcurrentWorkOnRoot 方法的调用。这取决于本次更新是同步更新还是异步更新，render结束完后会进入commit
2. commit阶段的开始
开始于 commitRoot 方法的调用。其中rootFiber会作为传参
此时，状态为

```text
触发状态更新（根据场景调用不同方法）
 |
 |
 v
 ？
 |
 |
 v
render阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）
 |
 |
 v
commit阶段（`commitRoot`）
```

### 创建update对象

在react里，触发状态更新的操作包括：
- ReactDOM.render
- this.setState
- this.forceUpdate
- useState
- useReducer

Q：如何在调用场景不同的情况下，接入同一套状态管理机制？
在每次状态更新，都会创建保存一个更新状态相关的对象，称为Update，在render的beginwork中会根据Update得到新的state

### 从fiber到root

render阶段是从rootFiber开始向下遍历。那么如何从触发状态更新的fiber得到rootFiber呢？

调用markUpdateLaneFromFiberToRoot方法。

地址：
https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L636

该方法做的工作可以概括为：从触发状态更新的fiber一直向上遍历到rootFiber，并返回rootFiber。

### 调度更新

现在有一个rootFiber，该rootFiber对应的Fiber树中某个Fiber节点包含一个Update。
接下来通知Scheduler根据更新的优先级，决定以同步还是异步的方式调度本次更新。
这里调用的方法是ensureRootIsScheduled

地址：
https://github.com/facebook/react/blob/b6df4417c79c11cfb44f965fab55b573882b1d54/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L602

ensureRootIsScheduled核心代码：

```js
if (newCallbackPriority === SyncLanePriority) {
    // 任务已经过期，需要同步执行render阶段
    newCallbackNode = scheduleSyncCallback(
        performSyncWorkOnRoot.bind(null, root)
    );
    } else {
    // 根据任务优先级异步执行render阶段
    var schedulerPriorityLevel = lanePriorityToSchedulerPriority(
        newCallbackPriority
    );
    newCallbackNode = scheduleCallback(
        schedulerPriorityLevel,
        performConcurrentWorkOnRoot.bind(null, root)
    );
}
```

至此，状态更新的流程已经通了

```text
触发状态更新（根据场景调用不同方法）
 |
 |
 v
创建Update对象（后面详解）
 |
 |
 v
从fiber到root（`markUpdateLaneFromFiberToRoot`）
 |
 |
 v
调度更新（`ensureRootIsScheduled`）
 |
 |
 v
render阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）
 |
 |
 v
commit阶段（`commitRoot`）
```

## Update

通过代码版本控制类比

1. 同步更新

在没有代码版本控制前，我们在代码中逐步叠加功能。一切看起来井然有序，直到我们遇到了一个紧急线上bug（红色节点）

如果要修改，需要先将之前的代码提交；
所有通过ReactDOM.render创建的应用都是通过类似的方式更新状态，没有优先级，高优先级需要排在其他更新的后面

2. 并发更新

如果有了代码版本控制，需要发布urgent变更，暂存当前已有的修改，在master上直接修复

修复后使用 git rebase 和分支连接，当前开发的分支是基于修复bug的最新的master分支

在React中，通过ReactDOM.createBlockingRoot和ReactDOM.createRoot创建的应用会采用并发的方式更新状态；
高优更新（红色节点）中断正在进行中的低优更新（蓝色节点），先完成render - commit流程；
待高优更新完成后，低优更新基于高优更新的结果重新更新；

### update的分类

触发方法 组件
ReactDOM.render HostRoot
this.setState ClassComponent
this.forceUpdate ClassComponent
useState FunctionComponent
useReducer FunctionComponent

|  触发方法    | 组件 | 
| ---- | ---- | 
| ReactDOM.render | HostRoot |
| this.setState | ClassComponent | 
| this.forceUpdate | ClassComponent | 
| useState | FunctionComponent | 
| useReducer | FunctionComponent | 

共有三种组件支持Update：HostRoot 、ClassComponent、FunctionComponent，其中，ClassComponent与HostRoot共用一套Update结构，FunctionComponent单独使用一种Update结构

虽然他们的结构不同，但是工作机制与工作流程大体相同。在本节我们介绍前一种Update，FunctionComponent对应的Update在后面讲解

### Update结构

ClassComponent与HostRoot（即rootFiber.tag对应类型）共用同一种Update结构

```js
const update: Update<*> = {
    eventTime,
    lane,
    suspenseConfig,
    tag: UpdateState,
    payload: null,
    callback: null,
    next: null,
};
```
- eventTime：任务时间，通过performance.now()获取的毫秒数；
- lane：优先级相关字段；
- suspenseConfig：Suspense相关；
- tag：更新的类型，包括UpdateState | ReplaceState | ForceUpdate | CaptureUpdate；
- payload：更新挂载的数据，不同类型组件挂载的数据不同。对于ClassComponent，payload为
- this.setState的第一个传参。对于HostRoot，payload为ReactDOM.render的第一个传参；
- callback：commit layout中支持的回调函数。
- next：与其他Update连接形成链表。

### Update与Fiber联系

Fiber节点组成Fiber树，页面中最多同时存在两棵Fiber树：
- 代表当前页面状态的current Fiber树
- 代表正在render阶段的workInProgress Fiber树
类似Fiber节点组成Fiber树，Fiber节点上的多个Update会组成链表并被包含在fiber.updateQueue中。

Q：什么情况下，一个Fiber节点会有多个Update

```js
onClick() {
    this.setState({
        a: 1
    })
    this.setState({
        b: 2
    })
}
```

Fiber节点最多同时存在两个updateQueue：
current fiber保存的updateQueue即current updateQueue
workInProgress fiber保存的updateQueue即workInProgress updateQueue

在commit阶段完成页面渲染后，workInProgress Fiber树变为current Fiber树，workInProgress Fiber树内Fiber节点的updateQueue就变成current updateQueue

### updateQueue

updateQueue有三种类型，其中针对HostComponent的类型在completeWork里讲过。
剩下两种类型和Update的两种类型对应
ClassComponent与HostRoot使用的UpdateQueue结构如下：

```js
const queue: UpdateQueue<State> = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
        pending: null,
    },
    effects: null,
};
```

- baseState：本次更新前该Fiber节点的state，Update基于该state计算更新后的state，可以将baseState类比心智模型中的master分支；
- firstBaseUpdate与lastBaseUpdate：本次更新前该Fiber节点已保存的Update。以链表形式存在，链表头为firstBaseUpdate，链表尾为lastBaseUpdate。之所以在更新产生前该Fiber节点内就存在Update，是由于某些Update优先级较低所以在上次render阶段由Update计算state时被跳过，可以将baseUpdate类比心智模型中执行git rebase基于的commit（节点D）；
- shared.pending：触发更新时，产生的Update会保存在shared.pending中形成单向环状链表。当由Update计算state时这个环会被剪开并连接在lastBaseUpdate后面，可以将shared.pending类比心智模型中本次需要提交的commit（节点ABC）。
- effects：数组。保存update.callback !== null的Update；

### demo

假设有一个fiber刚经历commit阶段完成渲染。
该fiber上有两个由于优先级过低所以在上次的render阶段并没有处理的Update。他们会成为下次更新的baseUpdate。

我们称其为u1和u2，其中u1.next === u2。
```js
fiber.updateQueue.firstBaseUpdate === u1;
fiber.updateQueue.lastBaseUpdate === u2;
u1.next === u2;
```

我们用-->表示链表的指向：

```js
fiber.updateQueue.baseUpdate: u1 --> u2
```

现在我们在fiber上触发两次状态更新，这会先后产生两个新的Update，我们称为u3和u4。每个 update 都会插入到 updateQueue 队列上
当插入u3后：

```js
fiber.updateQueue.shared.pending === u3;
u3.next === u3;
```

shared.pending的环状链表，用图表示为：

```js
fiber.updateQueue.shared.pending: u3 ─────┐
                                    ^     |

                                    └──────┘
```

接着插入u4之后：

```js
fiber.updateQueue.shared.pending = u4;
u4.next === u3;
u3.next === u4;
```

shared.pending是环状链表，用图表示为：

```js
fiber.updateQueue.shared.pending: u4 ──> u3
                                    ^      |

                                    └──────┘
```

shared.pending 会保证始终指向最后一个插入的update
更新调度完成后进入render阶段
此时shared.pending的环被剪开并连接在updateQueue.lastBaseUpdate后面：

```js
fiber.updateQueue.baseUpdate: u1 --> u2 --> u3 --> u4
```

接下来遍历updateQueue.baseUpdate链表，以fiber.updateQueue.baseState为初始state，依次与遍历到的每个Update计算并产生新的state；

在遍历时如果有优先级低的Update会被跳过；
当遍历完成后获得的state，就是该Fiber节点在本次更新的state

state的变化在render阶段产生与上次更新不同的JSX对象，通过Diff算法产生effectTag，在commit阶段渲染在页面上，同时，渲染完成后workInProgress Fiber树变为current Fiber树，整个更新流程结束。

## 深入理解优先级

### 什么是优先级

状态更新由用户交互产生，用户心里对交互执行顺序有个预期。React根据⼈机交互研究的结果中用户对交互的预期顺序为交互产生的状态更新赋予不同优先级

- 生命周期方法：同步执行；
- 受控的用户输入：比如输入框内输入文字，同步执行；
- 交互事件：比如动画，高优先级执行；
- 其他：比如数据请求，低优先级执行；

### 如何调度优先级

React会调用Scheduler提供的方法runWithPriority，该方法接收一个优先级常量与一个回调函数作为参数。回调函数会以优先级高低为顺序排列在一个定时器中并在合适的时间触发。

unstable_runWithPriority地址：
https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/Scheduler.js#L217

scheduler优先级常量定义地址：
https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/scheduler/src/SchedulerPriorities.js

### demo

![priority](../images/priority.png)

以上有两个Update。我们将“关闭黑夜模式”产生的Update称为u1，输入字母“I”产生的Update称为u2其中u1先触发并进入render阶段。其优先级较低，执行时间较长。此时：

```js
fiber.updateQueue = {
    baseState: {
        blackTheme: true,
        text: 'H'
    },
    firstBaseUpdate: null,
    lastBaseUpdate: null
    shared: {
        pending: u1
    },
    effects: null
};
```

在u1完成render阶段前用户通过键盘输入字母“I”，产生了u2。u2属于受控的用户输入，优先级高于u1，于是中断u1产生的render阶段。

```js
fiber.updateQueue.shared.pending === u2 ----> u1
                                    ^        |
                                    |________|
// 即
u2.next === u1;
u1.next === u2;
```

其中u2优先级高于u1。
接下来进入u2产生的render阶段。
在 processUpdateQueue 方法中，shared.pending环状链表会被剪开并拼接在baseUpdate后面。需要明确一点，shared.pending指向最后一个pending的update，所以实际执行时update的顺序为：
u1 -- u2

接下来遍历baseUpdate，处理优先级合适的Update（这一次处理的是更高优的u2）；
由于u2不是baseUpdate中的第一个update，在其之前的u1由于优先级不够被跳过；
update之间可能有依赖关系，所以被跳过的update及其后面所有update会成为下次更新的baseUpdate。（即u1 -- u2）;
最终u2完成render - commit阶段；

```js
fiber.updateQueue = {
    baseState: {
    blackTheme: true,
        text: 'HI'
    },
    firstBaseUpdate: u1,
    lastBaseUpdate: u2
    shared: {
        pending: null
    },
    effects: null
};
```

在commit阶段结尾会再调度一次更新。在该次更新中会基于baseState中firstBaseUpdate保存的u1，开启一次新的render阶段。

```js
fiber.updateQueue = {
    baseState: {
        blackTheme: false,
        text: 'HI'
    },
    firstBaseUpdate: null,
    lastBaseUpdate: null
    shared: {
        pending: null
    },
    effects: null
};
```

可以看到，u2执行了2次，相对应的render阶段的生命周期 componentWillXXX也会执行2次，这就是为什么这些生命周期会被标记为unsafe_；

Q：render阶段可能会被中断，如何保证 updateQueue 中的Update不会丢失？

在render阶段，shared.pending的环被剪开并连接在updateQueue.lastBaseUpdate后面。实际上shared.pending会被同时连接在workInProgress updateQueue.lastBaseUpdate与currentupdateQueue.lastBaseUpdate后面。
当render阶段被中断后重新开始时，会基于current updateQueue克隆出workInProgressupdateQueue。由于current updateQueue.lastBaseUpdate已经保存了上一次的Update，所以不会丢失
当commit阶段完成渲染，由于workInProgress updateQueue.lastBaseUpdate中保存了上一次的Update，所以 workInProgress Fiber树变成current Fiber树后也不会造成Update丢失

Q：如何保证状态依赖的连续性？

当某个Update由于优先级低而被跳过时，保存在baseUpdate中的不仅是该Update，还包括链表中该Update之后的所有Update。

考虑如下例子：

```js
baseState: ''
shared.pending: A1 --> B2 --> C1 --> D2
```

其中字母代表该Update要在页面插入的字母，数字代表优先级，值越低优先级越高。
第一次render，优先级为1。

```js
baseState: ''
baseUpdate: null
render阶段使用的Update: [A1, C1]
memoizedState: 'AC'
```

其中B2由于优先级为2，低于当前优先级，所以他及其后面的所有Update会被保存在baseUpdate中作为下次更新的Update（即B2 C1 D2）。

这么做是为了保持状态的前后依赖顺序。
第二次render，优先级为2。

```js
baseState: 'A'
baseUpdate: B2 --> C1 --> D2
render阶段使用的Update: [B2, C1, D2]
memoizedState: 'ABCD'
```

此时，React能保证最终的状态一定和用户触发的交互一致，但是中间过程状态无法保证

##  ReactDOM.render执行流程

首次执行ReactDOM.render会创建fiberRootNode和rootFiber。其中fiberRootNode是整个应用的根节点，rootFiber是要渲染组件所在组件树的根节点

```js
// container指ReactDOM.render的第二个参数（即应用挂载的DOM节点）
root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
    container,
    forceHydrate,
);
fiberRoot = root._internalRoot;
```

地址：
https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-dom/src/client/ReactDOMLegacy.js#L193

legacyCreateRootFromDOMContainer方法内部会调用createFiberRoot方法完成fiberRootNode和rootFiber的创建以及关联。并初始化updateQueue

```js
export function createFiberRoot(
    containerInfo: any,
    tag: RootTag,
    hydrate: boolean,
    hydrationCallbacks: null | SuspenseHydrationCallbacks,
): FiberRoot {
    // 创建fiberRootNode
    const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate):
    any);

    // 创建rootFiber
    const uninitializedFiber = createHostRootFiber(tag);
    // 连接rootFiber与fiberRootNode
    root.current = uninitializedFiber;
    uninitializedFiber.stateNode = root;
    // 初始化updateQueue
    initializeUpdateQueue(uninitializedFiber);
    return root;
}
```

### 创建Update

地址：
https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberReconciler.new.js#L255

```js
export function updateContainer(
    element: ReactNodeList,
    container: OpaqueRoot,
    parentComponent: ?React$Component<any, any>,
    callback: ?Function,
): Lane {
    // ...省略与逻辑不相关代码
    // 创建update
    const update = createUpdate(eventTime, lane, suspenseConfig);

    // update.payload为需要挂载在根节点的组件
    update.payload = {element};
    // callback为ReactDOM.render的第三个参数 —— 回调函数
    callback = callback === undefined ? null : callback;
    if (callback !== null) {
        update.callback = callback;
    }
    // 将生成的update加入updateQueue
    enqueueUpdate(current, update);
    // 调度更新
    scheduleUpdateOnFiber(current, lane, eventTime);
    // ...省略与逻辑不相关代码
}
```

所以完整流程为：

```text
创建fiberRootNode、rootFiber、updateQueue（`legacyCreateRootFromDOMContainer
`）
 |
 |
 v
创建Update对象（`updateContainer`）
 |
 |
 v
从fiber到root（`markUpdateLaneFromFiberToRoot`）
 |
 |
 v
调度更新（`ensureRootIsScheduled`）
 |
 |
 v
render阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）
 |
 |
 v
commit阶段（`commitRoot`）
```

### React其他入口函数

当前React共有三种模式：
- legacy，这是当前React使用的方式。当前没有计划删除本模式，但是这个模式可能不支持一些新功能；
- blocking，开启部分concurrent模式特性的中间模式。目前正在实验中。作为迁移到concurrent模式的第一个步骤；
- concurrent，面向未来的开发模式。我们之前讲的任务中断/任务优先级都是针对concurrent模式；

基于此原因，可以通过不同的入口函数开启不同模式：
- legacy -- ReactDOM.render(/<App //>, rootNode)
- blocking -- ReactDOM.createBlockingRoot(rootNode).render(/<App //>)
- concurrent -- ReactDOM.createRoot(rootNode).render(/<App //>)

### this.setState

this.setState 会调用this.updater.enqueueSetState

地址：
https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactBaseClasses.js#L57

```js
Component.prototype.setState = function (partialState, callback) {
    if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
        {
            throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
        }
    }
    this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
```

enqueueSetState就是我们从创建update到调度update

```js
enqueueSetState(inst, payload, callback) {
    // 通过组件实例获取对应fiber
    const fiber = getInstance(inst);
    const eventTime = requestEventTime();
    const suspenseConfig = requestCurrentSuspenseConfig();
    // 获取优先级
    const lane = requestUpdateLane(fiber, suspenseConfig);
    // 创建update
    const update = createUpdate(eventTime, lane, suspenseConfig);
    update.payload = payload;
    // 赋值回调函数
    if (callback !== undefined && callback !== null) {
        update.callback = callback;
    }
    // 将update插入updateQueue
    enqueueUpdate(fiber, update);
    // 调度update
    scheduleUpdateOnFiber(fiber, lane, eventTime);
}
```

#### this.forceUpdate

在this.updater上，除了enqueueSetState外，还存在enqueueForceUpdate，在this.forceUpdate时调用；

```js
enqueueForceUpdate(inst, callback) {
    const fiber = getInstance(inst);
    const eventTime = requestEventTime();
    const suspenseConfig = requestCurrentSuspenseConfig();
    const lane = requestUpdateLane(fiber, suspenseConfig);
    const update = createUpdate(eventTime, lane, suspenseConfig);
    // 赋值tag为ForceUpdate
    update.tag = ForceUpdate;
    if (callback !== undefined && callback !== null) {
        update.callback = callback;
    }
    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
};
```

此时，当某次更新含有tag为ForceUpdate的Update，那么当前ClassComponent不会受其他性能优化手段（shouldComponentUpdate|PureComponent）影响，一定会更新。

## 极简hook实现

```js
function App() {
    const [num, updateNum] = useState(0);
    return <p onClick={() => updateNum(num => num + 1)}>{num}</p>;
}
```

1. 通过一些途径产生更新，更新会造成组件render--updateNum；
2. 组件render时useState返回的num为更新后的结果；


其中步骤1的更新可以分为mount和update：

1. 调用ReactDOM.render会产生mount的更新，更新内容为useState的initialValue（即0）。
2. 点击p标签触发updateNum会产生一次update的更新，更新内容为num => num + 1。

### 更新是什么

通过一些途径产生更新，更新会造成组件render

```js
const update = {
    // 更新执行的函数
    action,
    // 与同一个Hook的其他更新形成链表
    next: null
}
```

### update的数据结构

加入有多个update，如何组合起来

```jsx
// 之前
return <p onClick={() => updateNum(num => num + 1)}>{num}</p>;
// 之后
return <p onClick={() => {
 updateNum(num => num + 1);
 updateNum(num => num + 1);
 updateNum(num => num + 1);
}}>{num}</p>;
```

通过环形单向链表
调用updateNum实际上是dispatchAction.bind(null, hook.queue)

```js
function dispatchAction(queue, action) {
    // 创建update
    const update = {
    action,
        next: null
    }
    // 环状单向链表操作
    if (queue.pending === null) {
        update.next = update;
    } else {
        update.next = queue.pending.next;
        queue.pending.next = update;
    }
    queue.pending = update;
    // 模拟React开始调度更新
    schedule();
}
```

当产生第一个update（我们叫他u0），此时queue.pending === null。
update.next = update;即u0.next = u0，他会和自己首尾相连形成单向环状链表。
然后queue.pending = update;即queue.pending = u0

```jsx
queue.pending = u0 ----->
                ^       |
                |       |
                ---------

```

当产生第二个update（我们叫他u1），update.next = queue.pending.next;，此时queue.pending.next === u0， 即u1.next = u0。
queue.pending.next = update;，即u0.next = u1。然后queue.pending = update;即queue.pending = u1

```jsx
queue.pending = u1 ---> u0
                ^       |
                |       |
                ---------
```

queue.pending始终指向最后一个插入的update

### 状态如何保存

更新产生的update对象会保存在queue中。
不同于ClassComponent的实例可以存储数据
对于FunctionComponent，queue存储对应的fiber中

```jsx
// App组件对应的fiber对象
const fiber = {
    // 保存该FunctionComponent对应的Hooks链表
    memoizedState: null,
    // 指向App函数
    stateNode: App
};
```

### Hooks数据结构

```js
hook = {
    // 保存update的queue，即上文介绍的queue
    queue: {
        pending: null
    },
    // 保存hook对应的state
    memoizedState: initialState,
    // 与下一个Hook连接形成单向无环链表
    next: null
}
```

Q：update与hook的关系
每个useState对应一个hook对象。

调用const [num, updateNum] = useState(0);时updateNum（即上文介绍的dispatchAction）产生的update保存在useState对应的hook.queue中

### 模拟react调度更新流程

实现通过操作产生更新，更新造成组件render

```jsx
function dispatchAction(queue, action) {
    // ...创建update

    // ...环状单向链表操作
    // 模拟React开始调度更新
    schedule();
}
// 模拟调度
// 首次render时是mount
isMount = true;
function schedule() { 
    // 更新前将workInProgressHook重置为fiber保存的第一个Hook
    workInProgressHook = fiber.memoizedState;
    // 触发组件render
    fiber.stateNode();
    // 组件首次render为mount，以后再触发的更新为update
    isMount = false;
}
// 每当遇到下一个useState，我们移动workInProgressHook的指针
workInProgressHook = workInProgressHook.next;
// 保证了每次组件render时useState的调用顺序及数量保持一致
// 可以通过workInProgressHook找到当前useState对应的hook对象。
```

### 计算state

组件render时，useState返回的值为更新后的结果，即一个完整的useState

```js
function useState(initialState) {
    // 当前useState使用的hook会被赋值该该变量
    let hook;
    if (isMount) {
        hook = {
            queue: {
                pending: null
            },
            memoizedState: initialState,
            next: null
        }
        // 将hook插入fiber.memoizedState链表末尾
        if (!fiber.memoizedState) {
            fiber.memoizedState = hook;
        } else {
            workInProgressHook.next = hook;
        }
        // 移动workInProgressHook指针
        workInProgressHook = hook;
    } else {
        // update时找到对应hook
        hook = workInProgressHook;
        // 移动workInProgressHook指针
        workInProgressHook = workInProgressHook.next;
    }
    let baseState = hook.memoizedState;
    if (hook.queue.pending) {
    // 获取update环状单向链表中第一个update
    let firstUpdate = hook.queue.pending.next;

    do {
        // 执行update action
        const action = firstUpdate.action;
        baseState = action(baseState);
        firstUpdate = firstUpdate.next;

    // 最后一个update执行完后跳出循环
    } while (firstUpdate !== hook.queue.pending.next)

        // 清空queue.pending
        hook.queue.pending = null;
    }
    hook.memoizedState = baseState;
    return [baseState, dispatchAction.bind(null, hook.queue)];
}
```

## Hooks数据结构

### dispatcher

上文中，useState使用isMount区分mount和update
在真实的Hooks中，组件mount时的hook与update时的hook来源于不同的对象，这类对象在源码中被称为dispatcher

```jsx
// mount时的Dispatcher
const HooksDispatcherOnMount: Dispatcher = {
    useCallback: mountCallback,
    useContext: readContext,
    useEffect: mountEffect,
    useImperativeHandle: mountImperativeHandle,
    useLayoutEffect: mountLayoutEffect,
    useMemo: mountMemo,
    useReducer: mountReducer,
    useRef: mountRef,
    useState: mountState,
    // ...省略
};
// update时的Dispatcher
const HooksDispatcherOnUpdate: Dispatcher = {
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: updateReducer,
    useRef: updateRef,
    useState: updateState,
    // ...省略
};
```

mount时调用的hook和update时调用的hook其实是两个不同的函数。

在FunctionComponent render前，会根据FunctionComponent对应fiber的以下条件区分mount与update

```js
current === null || current.memoizedState === null
```

并将不同情况对应的dispatcher赋值给全局变量ReactCurrentDispatcher的current属性

```js
ReactCurrentDispatcher.current =
 current === null || current.memoizedState === null
 ? HooksDispatcherOnMount
 : HooksDispatcherOnUpdate; 
```

地址：
https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L409

### dispatch异常场景

```js
useEffect(() => {
 useState(0);
})
```

实际上，ReactCurrentDispatcher.current已经指向ContextOnlyDispatcher，所以调用useState实际会调用throwInvalidHookError，直接抛出异常

```js
export const ContextOnlyDispatcher: Dispatcher = {
    useCallback: throwInvalidHookError,
    useContext: throwInvalidHookError,
    useEffect: throwInvalidHookError,
    useImperativeHandle: throwInvalidHookError,
    useLayoutEffect: throwInvalidHookError,
 // ...省略
}
```

地址：
https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L458

### Hook数据结构

```jsx
const hook: Hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
};
```

除了memoizedState，其余与updateQueue一致
useState：对于const [state, updateState] = useState(initialState)，memoizedState保存state的值
useReducer：对于const [state, dispatch] = useReducer(reducer, {});，memoizedState保存state的值
useEffect：memoizedState保存包含useEffect回调函数、依赖项等的链表数据结构effect。effect
链表同时会保存在fiber.updateQueue中
useRef：对于useRef(1)，memoizedState保存{current: 1}
useMemo：对于useMemo(callback, [depA])，memoizedState保存[callback(), depA]
useCallback：对于useCallback(callback, [depA])，memoizedState保存[callback, depA]。与useMemo的区别是，useCallback保存的是callback函数本身，而useMemo保存的是callback函数的执行结果
有些hook是没有memoizedState的，比如：
useContext

### useState与useReducer

useState和useReducer是Redux作者加入React后的一个核心贡献：将Redux的思想带入到React里本质来说，useState只是预置了reducer的useReducer

#### 概览

```jsx
function App() {
    const [state, dispatch] = useReducer(reducer, {a: 1});
    const [num, updateNum] = useState(0);

    return (
        <div>
        <button onClick={() => dispatch({type: 'a'})}>{state.a}</button>
        <button onClick={() => updateNum(num => num + 1)}>{num}</button>
        </div>
    )
}
```

- 声明阶段即App调用时，会依次执行useReducer与useState方法
- 调用阶段即点击按钮后，dispatch或updateNum被调用时

#### 声明阶段

当FunctionComponent进入render阶段的beginWork时，会调用renderWithHooks方法该方法内部会执行FunctionComponent对应函数（即fiber.type）

```js
function useState(initialState) {
    var dispatcher = resolveDispatcher();
    return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
    var dispatcher = resolveDispatcher();
    return dispatcher.useReducer(reducer, initialArg, init);
}
```

mount时

mount时，useReducer会调用mountReducer，useState会调用mountState

```jsx
function mountState<S>(
    initialState: (() => S) | S,
): [S, Dispatch<BasicStateAction<S>>] {
    // 创建并返回当前的hook
    const hook = mountWorkInProgressHook();
    // ...赋值初始state
    // 创建queue
    const queue = (hook.queue = {
        pending: null,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: (initialState: any),
    });
    // ...创建dispatch
    return [hook.memoizedState, dispatch];
}
function mountReducer<S, I, A>(
    reducer: (S, A) => S,
    initialArg: I,
    init?: I => S,
): [S, Dispatch<A>] {
    // 创建并返回当前的hook
    const hook = mountWorkInProgressHook();
    // ...赋值初始state
    // 创建queue
    const queue = (hook.queue = {
        pending: null,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: (initialState: any),
    });
    // ...创建dispatch
    return [hook.memoizedState, dispatch];
}
```
其中，mountWorkInProgressHook对应创建并返回对应的Hook，以上两个hooks的区别：queue参数的lastRenderedReducer字段

```js
const queue = (hook.queue = {
    pending: null,
    // 保存dispatchAction.bind()的值
    dispatch: null,
    // 上一次render时使用的reducer
    lastRenderedReducer: reducer,
    // 上一次render时的state
    lastRenderedState: (initialState: any),
});
```

useReducer的lastRenderedReducer为传入的reducer参数。useState的lastRenderedReducer为basicStateReducer，basicStateReducer如下：

```jsx
function basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {
    return typeof action === 'function' ? action(state) : action;
}
```

update时

在update时，useReducer和useState调用的是同一个函数 updateReducer

地址：
https://github.com/acdlite/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.new.js#L665

```jsx
// 找到对应的hook，根据update计算该hook的新state并返回
function updateReducer<S, I, A>(
    reducer: (S, A) => S,
    initialArg: I,
    init?: I => S,
): [S, Dispatch<A>] {
    // 获取当前hook
    const hook = updateWorkInProgressHook();
    const queue = hook.queue;

    queue.lastRenderedReducer = reducer;
    // ...同update与updateQueue类似的更新逻辑
    const dispatch: Dispatch<A> = (queue.dispatch: any);
    return [hook.memoizedState, dispatch];
}
```

#### 调用阶段

调用阶段会执行dispatchAction，此时该FunctionComponent对应的fiber以及hook.queue已经通过调用bind方法预先作为参数传入

```jsx
// 创建update，将update加入queue.pending中，并开启调度。
function dispatchAction(fiber, queue, action) {
    // ...创建update
    var update = {
        eventTime: eventTime,
        lane: lane,
        suspenseConfig: suspenseConfig,
        action: action,
        eagerReducer: null,
        eagerState: null,
        next: null
    };
    // ...将update加入queue.pending

    var alternate = fiber.alternate;
    if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
        // render阶段触发的更新
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpd
        ate = true;
    } else {
        if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
        // ...fiber的updateQueue为空，优化路径
        }
        scheduleUpdateOnFiber(fiber, lane, eventTime);
    }
}
```

### useEffect

参考commit阶段时useEffect工作流
:::tip
在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。
:::

#### flushPassiveEffectsImpl

flushPassiveEffects内部会设置优先级，并执行flushPassiveEffectsImpl

地址：
https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2458

flushPassiveEffectsImpl主要做三件事：
- 调用该useEffect在上一次render时的销毁函数；
- 调用该useEffect在本次render时的回调函数；
- 如果存在同步任务，不需要等待下次事件循环的宏任务，提前执行；

这里主要关注前两件事：

- 销毁函数的执行

useEffect的执行需要保证所有组件useEffect的销毁函数必须都执行完后才能执行任意一个组件的useEffect的回调函数。

这是因为多个组件间可能共用同一个ref。
如果不是按照“全部销毁”再“全部执行”的顺序，那么在某个组件useEffect的销毁函数中修改的ref.current可能影响另一个组件useEffect的回调函数中的同一个ref的current属性。

在useLayoutEffect中也有同样的问题，所以他们都遵循“全部销毁”再“全部执行”的顺序。

所以，会遍历并执行所有useEffect的销毁函数

```js
// pendingPassiveHookEffectsUnmount中保存了所有需要执行销毁的useEffect
const unmountEffects = pendingPassiveHookEffectsUnmount;
pendingPassiveHookEffectsUnmount = [];
for (let i = 0; i < unmountEffects.length; i += 2) {
    const effect = ((unmountEffects[i]: any): HookEffect);
    const fiber = ((unmountEffects[i + 1]: any): Fiber);
    const destroy = effect.destroy;
    effect.destroy = undefined;
    if (typeof destroy === 'function') {
        // 销毁函数存在则执行
        try {
            destroy();
        } catch (error) {
            captureCommitPhaseError(fiber, error);
        }
    }
}
```

其中pendingPassiveHookEffectsUnmount数组的索引i保存需要销毁的effect，i+1保存该effect对应的fiber

- 回调函数的执行

遍历数组，执行对应effect的回调函数。

```js
// pendingPassiveHookEffectsMount中保存了所有需要执行回调的useEffect
const mountEffects = pendingPassiveHookEffectsMount;
pendingPassiveHookEffectsMount = [];
for (let i = 0; i < mountEffects.length; i += 2) {
    const effect = ((mountEffects[i]: any): HookEffect);
    const fiber = ((mountEffects[i + 1]: any): Fiber);

    try {
        const create = effect.create;
        effect.destroy = create();
    } catch (error) {
        captureCommitPhaseError(fiber, error);
    }
}
```

### useRef

ref是reference（引用）的缩写。在React中，我们习惯用ref保存DOM。
对于`useRef(1)`，memoizedState保存`{current: 1}`

#### useRef的两个状态

在mount和update时对应了两个dispatcher

地址：
https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberHooks.old.js#L1208-L1221

```jsx
function mountRef<T>(initialValue: T): {|current: T|} {
    // 获取当前useRef hook
    const hook = mountWorkInProgressHook();
    // 创建ref
    const ref = {current: initialValue};
    hook.memoizedState = ref;
    return ref;
}
function updateRef<T>(initialValue: T): {|current: T|} {
    // 获取当前useRef hook
    const hook = updateWorkInProgressHook();
    // 返回保存的数据
    return hook.memoizedState;
}
```

useRef仅仅是返回一个包含current属性的对象，可以看React.createRef，证明了ref在mount时只有current属性

```js
export function createRef(): RefObject {
    const refObject = {
        current: null,
    };
    return refObject;
}
```

#### Ref工作流程

在React中，HostComponent、ClassComponent、ForwardRef可以赋值ref属性。

```jsx
// HostComponent
<div ref={domRef}></div>
// ClassComponent / ForwardRef
<App ref={cpnRef} />
```

其中，ForwardRef只是将ref作为第二个参数传递下去，不会进入ref的工作流程。

因为HostComponent在commit阶段的mutation阶段执行DOM操作。

所以，对应ref的更新也是发生在mutation阶段。
同时，mutation阶段执行DOM操作的依据为effectTag。
所以，对于HostComponent、ClassComponent如果包含ref操作，那么也会赋值相应的effectTag。

```jsx
// ...
export const Placement = /* */ 0b0000000000000010;
export const Update = /* */ 0b0000000000000100;
export const Deletion = /* */ 0b0000000000001000;
export const Ref = /* */ 0b0000000010000000;
// ...
```

所以，ref的工作流程可以分为两部分：
1. render阶段为含有ref属性的fiber添加Ref effectTag
2. commit阶段为包含Ref effectTag的fiber执行对应操作

#### render阶段

在render阶段的beginWork与completeWork中有个同名方法markRef用于为含有ref属性的fiber增加Ref effectTag

```jsx
// beginWork的markRef
function markRef(current: Fiber | null, workInProgress: Fiber) {
    const ref = workInProgress.ref;
    if (
        (current === null && ref !== null) ||
        (current !== null && current.ref !== ref)
    ) {
        // Schedule a Ref effect
        workInProgress.effectTag |= Ref;
    }
}
// completeWork的markRef
function markRef(workInProgress: Fiber) {
    workInProgress.effectTag |= Ref;
}
```
markRef在beginWork地址：
https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.old.js#L693

在completeWork地址：
https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCompleteWork.old.js#L153

在beginWork中，如下两处调用了markRef：
- updateClassComponent内的finishClassComponent，对应ClassComponent；注意 ClassComponent 即使 shouldComponentUpdate 为false该组件也会调用markRef
- updateHostComponent，对应HostComponent；
在completeWork中，如下两处调用了markRef：
- completeWork中的HostComponent类型
- completeWork中的ScopeComponent类型

总结下组件对应fiber被赋值Ref effectTag需要满的条件：
- fiber类型为HostComponent、ClassComponent
- 对于mount，workInProgress.ref !== null，即存在ref属性
- 对于update，current.ref !== workInProgress.ref，即ref属性改变

#### commit阶段

在commit阶段的mutation阶段中，对于ref属性改变的情况，需要先移除之前的ref。

地址：
https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L2342

```jsx
function commitMutationEffects(root: FiberRoot, renderPriorityLevel) {
    while (nextEffect !== null) {
        const effectTag = nextEffect.effectTag;
        // ...
        if (effectTag & Ref) {
            const current = nextEffect.alternate;
            if (current !== null) {
                // 移除之前的ref
                commitDetachRef(current);
            }
        }
    // ...
    }
    // ...

    function commitDetachRef(current: Fiber) {
        const currentRef = current.ref;
        if (currentRef !== null) {
            if (typeof currentRef === 'function') {
                // function类型ref，调用他，传参为null
                currentRef(null);
            } else {
            // 对象类型ref，current赋值为null
            currentRef.current = null;
            }
        }
    }
}
```

接下来进入ref的赋值阶段，commitLayoutEffect会执行commitAttachRef（赋值ref）

```jsx
function commitAttachRef(finishedWork: Fiber) {
    const ref = finishedWork.ref;
    if (ref !== null) {
        // 获取ref属性对应的Component实例
        const instance = finishedWork.stateNode;
        let instanceToUse;
        switch (finishedWork.tag) {
            case HostComponent:
            instanceToUse = getPublicInstance(instance);
            break;
            default:
            instanceToUse = instance;
        }
        // 赋值ref
        if (typeof ref === 'function') {
            ref(instanceToUse);
        } else {
            ref.current = instanceToUse;
        }
    }
}
```

### useMemo与useCallback

#### mount

```js
function mountMemo<T>(
    nextCreate: () => T,
    deps: Array<mixed> | void | null,
): T {
    // 创建并返回当前hook
    const hook = mountWorkInProgressHook();
    const nextDeps = deps === undefined ? null : deps;
    // 计算value
    const nextValue = nextCreate();
    // 将value与deps保存在hook.memoizedState
    hook.memoizedState = [nextValue, nextDeps];
    return nextValue;
}
function mountCallback<T>(callback: T, deps: Array<mixed> | void | null):
T {
    // 创建并返回当前hook
    const hook = mountWorkInProgressHook();
    const nextDeps = deps === undefined ? null : deps;
    // 将value与deps保存在hook.memoizedState
    hook.memoizedState = [callback, nextDeps];
    return callback;
}
```

- mountMemo会将回调函数(nextCreate)的执行结果作为value保存
- mountCallback会将回调函数作为value保存

#### update

```js
function updateMemo<T>(
    nextCreate: () => T,
    deps: Array<mixed> | void | null,
): T {
    // 返回当前hook
    const hook = updateWorkInProgressHook();
    const nextDeps = deps === undefined ? null : deps;
    const prevState = hook.memoizedState;
    if (prevState !== null) {
        if (nextDeps !== null) {
            const prevDeps: Array<mixed> | null = prevState[1];
            // 判断update前后value是否变化
            if (areHookInputsEqual(nextDeps, prevDeps)) {
                // 未变化
                return prevState[0];
            }
        }
    }
    // 变化，重新计算value
    const nextValue = nextCreate();
    hook.memoizedState = [nextValue, nextDeps];
    return nextValue;
}
function updateCallback<T>(callback: T, deps: Array<mixed> | void | null):
T {
    // 返回当前hook
    const hook = updateWorkInProgressHook();
    const nextDeps = deps === undefined ? null : deps;
    const prevState = hook.memoizedState;
    if (prevState !== null) {
        if (nextDeps !== null) {
            const prevDeps: Array<mixed> | null = prevState[1];
            // 判断update前后value是否变化
            if (areHookInputsEqual(nextDeps, prevDeps)) {
                // 未变化
                return prevState[0];
            }
        }
    }
    // 变化，将新的callback作为value
    hook.memoizedState = [callback, nextDeps];
    return callback;
}
```

对于update，这两个hook的唯一区别也是是回调函数本身还是回调函数的执行结果作为value。

## Concurrent Mode

### 概览

:::tip
Concurrent 模式是一组 React 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。
:::

Concurrent Mode是React16年重构 Fiber架构 的源动力，也是React未来的发展方向。

#### 底层架构--fiber架构

oncurrent Mode最关键的一点是：实现异步可中断的更新。
Fiber架构的意义在于，他将单个组件作为工作单元，使以组件为粒度的“异步可中断的更新”成为可能。

#### 架构的驱动力--Scheduler

当同步运行Fiber架构（通过ReactDOM.render），则Fiber架构与V15并无区别。
但是当我们配合时间切片，就能根据宿主环境性能，为每个工作单元分配一个可运行时间，实现“异步可中断的更新”

#### 架构运行策略--lane

基于当前的架构，当一次更新在运行过程中被中断，过段时间再继续运行，这就是“异步可中断的更新”；

当一次更新在运行过程中被中断，转而重新开始一次新的更新，我们可以说：后一次更新打断了前一次更新；
这就是优先级的概念：后一次更新的优先级更高，就会打断正在进行的前一次更新。
多个优先级之间如何互相打断？优先级能否升降？本次更新应该赋予什么优先级？
这就需要一个模型控制不同优先级之间的关系与行为，也就是lane

#### 上层实现

从源码层面讲，Concurrent Mode是一套可控的“多优先级更新架构”，落地的上层实现包括：

1. batchUpdates
2. Suspense
3. useDeferredValue


### scheduler原理及实现

scheduler实现功能：

1. 时间切片
2. 优先级调度

#### 时间切片原理

时间切片的本质是模拟实现requestIdleCallback

requestIdleCallback是在“浏览器重排/重绘”后如果当前帧还有空余时间时被调用的。

```text
一个task(宏任务) --
队列中全部job(微任务) --
requestAnimationFrame --
浏览器重排/重绘 --
requestIdleCallback
```

除去“浏览器重排/重绘”，下图是浏览器一帧中可以用于执行JS的时机。
一个task(宏任务) -- 队列中全部job(微任务) -- requestAnimationFrame -- 浏览器重排/重绘 --requestIdleCallback
requestIdleCallback是在“浏览器重排/重绘”后如果当前帧还有空余时间时被调用的。

浏览器并没有提供其他API能够在同样的时机（浏览器重排/重绘后）调用以模拟其实现。唯一能精准控制调用时机的API是requestAnimationFrame，他能让我们在“浏览器重排/重绘”之前执行JS。
这也是为什么我们通常用这个API实现JS动画 —— 这是浏览器渲染前的最后时机，所以动画能快速被渲染。

所以，Scheduler的时间切片功能是通过task（宏任务）实现的。
setTimeout：最常见
MessageChannel：执行时机比setTimeout更早

所以Scheduler将需要被执行的回调函数作为MessageChannel的回调执行。如果当前宿主环境不支持MessageChannel，则使用setTimeout

setTimeout：
https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L47-L55
MessageChannel：
https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L228-L234

在React的render阶段，开启Concurrent Mode时，每次遍历前，都会通过Scheduler提供的shouldYield方法判断是否需要中断遍历，使浏览器有时间渲染：

```js
function workLoopConcurrent() {
    // Perform work until Scheduler asks us to yield
    while (workInProgress !== null && !shouldYield()) {
        performUnitOfWork(workInProgress);
    }
}
```

在Schdeduler中，为任务分配的初始剩余时间为5ms，但随着应用运行，会通过fps动态调整分配给任务的可执行时间。

```js
forceFrameRate = function(fps) {
    if (fps < 0 || fps > 125) {
        // Using console['error'] to evade Babel and ESLint
        console['error'](
        'forceFrameRate takes a positive int between 0 and 125, ' +
        'forcing frame rates higher than 125 fps is not unsupported',
        );
        return;
    }
    if (fps > 0) {
        yieldInterval = Math.floor(1000 / fps);
    } else {
        // reset the framerate
        yieldInterval = 5;
    }
};
```

####  优先级调度

Scheduler是独立于React的包，对外暴露了一个方法unstable_runWithPriority。
这个方法接受一个优先级与一个回调函数，在回调函数内部调用获取优先级的方法都会取得第一个参数对应的优先级：

```js
function unstable_runWithPriority(priorityLevel, eventHandler) {
    switch (priorityLevel) {
        case ImmediatePriority:
        case UserBlockingPriority:
        case NormalPriority:
        case LowPriority:
        case IdlePriority:
        break;
        default:
        priorityLevel = NormalPriority;
    }
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = priorityLevel;
    try {
        return eventHandler();
    } finally {
        currentPriorityLevel = previousPriorityLevel;
    }
}
```

一共有5种优先级

```jsx
// Times out immediately
var IMMEDIATE_PRIORITY_TIMEOUT = -1;
// Eventually times out
var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
var NORMAL_PRIORITY_TIMEOUT = 5000;
var LOW_PRIORITY_TIMEOUT = 10000;
// Never times out
var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
```

### lane模型

lane模型就是react优先级的机制，可以用来

- 可以表示优先级的不同
- 可能同时存在几个同优先级的更新，所以还得能表示批的概念
- 方便进行优先级相关计算

#### 表示优先级不同

lane模型使用31位的二进制表示31条赛道，位数越小的优先级越高，某些相邻的位拥有相同优先级。

#### 表示“批”的概念

```js
const InputDiscreteLanes: Lanes = /* */ 0b0000000000000000000000000011000;
export const DefaultLanes: Lanes = /* */ 0b0000000000000000000111000000000;
const TransitionLanes: Lanes = /* */ 0b0000000001111111110000000000000;
```

其中的某些变量占了多个位，这就是批
其中InputDiscreteLanes是“用户交互”触发更新会拥有的优先级范围。
DefaultLanes是“请求数据返回后触发更新”拥有的优先级范围。
TransitionLanes是Suspense、useTransition、useDeferredValue拥有的优先级范围。
这其中有个细节，越低优先级的lanes占用的位越多。比如InputDiscreteLanes占了2个位，TransitionLanes占了9个位。
原因在于：越低优先级的更新越容易被打断，导致积压下来，所以需要更多的位。相反，最高优的同步更新的SyncLane不需要多余的lanes

#### 方便进行优先级相关计算

使用位运算符

```js
// 判断a b是否有交集
export function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane) {
 return (a & b) !== NoLanes;
}
// 计算b这个lanes是否是a对应的lanes的子集，只需要判断a与b按位与的结果是否为b：
export function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane) {
 return (set & subset) === subset;
}
// 将两个lane或lanes的位合并只需要执行按位或操作：
export function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
 return a | b;
}
```











