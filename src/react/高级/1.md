---
date: 2022-06-30
category:
  - react
tag:
  - react高级用法
---

# React高级用法

1. ⾼阶组件的⽤法及封装
2. Hooks详解
3. 异步组件
4. React 18 新特性

## 高阶组件用法及封装

⾼阶组件（HOC）是 React 中⽤于复⽤组件逻辑的⼀种⾼级技巧。HOC ⾃身不是 React API 的⼀部分，它是⼀种基于 React 的组合特性⽽形成的设计模式。
简单点说，就是组件作为参数，返回值也是组件的函数，它是纯函数，不会修改传⼊的组件，也不会使⽤继承来复制其⾏为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作⽤。

### 使⽤HOC的原因

1. 抽取重复代码，实现组件复⽤：相同功能组件复⽤
2. 条件渲染，控制组件的渲染逻辑（渲染劫持）：权限控制。
3. 捕获/劫持被处理组件的⽣命周期，常⻅场景：组件渲染性能追踪、⽇志打点。

### HOC实现⽅式

### 属性代理

使⽤组合的⽅式，将组件包装在容器上，依赖⽗⼦组件的⽣命周期关系来；
1. 返回stateless的函数组件
2. 返回class组件
- 操作props

```js
// 可以通过属性代理，拦截⽗组件传递过来的porps并进⾏处理。
// 返回⼀个⽆状态的函数组件
function HOC(WrappedComponent) {
  const newProps = { type: 'HOC' };
  return props => <WrappedComponent {...props} {...newProps}/>;
}
// 返回⼀个有状态的 class 组件
function HOC(WrappedComponent) {
  return class extends React.Component {
    render() {
      const newProps = { type: 'HOC' };
      return <WrappedComponent {...this.props} {...newProps}/>;
   }
 };
}
```
- 抽象state

```js
// 通过属性代理⽆法直接操作原组件的state，可以通过props和cb抽象state
function HOC(WrappedComponent) {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        name: '',
      };
      this.onChange = this.onChange.bind(this);
    }
    
    onChange = (event) => {
      this.setState({
        name: event.target.value,
      })
    }
    
    render() {
      const newProps = {
        name: {
          value: this.state.name,
          onChange: this.onChange,
        },
      };
      return <WrappedComponent {...this.props} {...newProps} />;
    }
 };
}
// 使⽤
@HOC
class Example extends Component {
  render() {
    return <input name="name" {...this.props.name} />;
  }
}
```

- 通过props实现条件渲染

```js
// 通过props来控制是否渲染及传⼊数据
import * as React from 'react';
function HOC (WrappedComponent) {
  return (props) => (
  <div>
   {
      props.isShow ? (
        <WrappedComponent
         {...props}
        />
     ) : <div>暂⽆数据</div>
   }
  </div>
 );
}
export default HOC;
```

- 其他元素wrapper传⼊的组件

```jsx
function withBackgroundColor(WrappedComponent) {
  return class extends React.Component {
    render() {
      return (
        <div style={{ backgroundColor: '#ccc' }}>
            <WrappedComponent {...this.props} {...newProps} />
        </div>
     );
   }
 };
}
```

### 反向继承

使⽤⼀个函数接受⼀个组件作为参数传⼊，并返回⼀个继承了该传⼊组件的类组件，且在返回组件的render() ⽅法中返回 super.render() ⽅法

```js
const HOC = (WrappedComponent) => {
  return class extends WrappedComponent {
    render() {
      return super.render();
   }
 }
}
```

1. 允许HOC通过this访问到原组件，可以直接读取和操作原组件的state/ref等；
2. 可以通过super.render()获取传⼊组件的render，可以有选择的渲染劫持；
3. 劫持原组件⽣命周期⽅法

```js
function HOC(WrappedComponent){
  const didMount = WrappedComponent.prototype.componentDidMount;
  
     // 继承了传⼊组件
    return class HOC extends WrappedComponent {
        async componentDidMount(){
            // 劫持 WrappedComponent 组件的⽣命周期
            if (didMount) {
                await didMount.apply(this);
            }
            ...
        }
        render(){
            //使⽤ super 调⽤传⼊组件的 render ⽅法
            return super.render();
        }
    }
}
```

- 读取/操作原组件的state

```js
function HOC(WrappedComponent){
    const didMount = WrappedComponent.prototype.componentDidMount;
    // 继承了传⼊组件
    return class HOC extends WrappedComponent {
        async componentDidMount(){
            if (didMount) {
                await didMount.apply(this);
            }
            // 将 state 中的 number 值修改成 2
            this.setState({ number: 2 });
        }
        render(){
            //使⽤ super 调⽤传⼊组件的 render ⽅法
            return super.render();
        }
    }
}
```

- 条件渲染

```js
const HOC = (WrappedComponent) =>
  class extends WrappedComponent {
    render() {
      if (this.props.isRender) {
        return super.render();
     } else {
        return <div>暂⽆数据</div>;
     }
   }
 }
```

- 修改react树

```js
// 修改返回render结果
function HigherOrderComponent(WrappedComponent) {
    return class extends WrappedComponent {
        render() {
            const tree = super.render();
            const newProps = {};
            if (tree && tree.type === 'input') {
                newProps.value = 'something here';
            }
            const props = {
                ...tree.props,
                ...newProps,
            };
            const newTree = React.cloneElement(tree, props,tree.props.children);
            return newTree;
        }
    };
}
```

### 属性代理和反向继承对⽐

1. 属性代理：从“组合”⻆度出发，有利于从外部操作wrappedComp，可以操作props，或者在wrappedComp 外加⼀些拦截器（如条件渲染等）；
2. 反向继承：从“继承”⻆度出发，从内部操作wrappedComp，可以操作组件内部的state，⽣命周期和render等，功能能加强⼤；

### 举个例子

- ⻚⾯复⽤（属性代理）

```js
// views/PageA.js
import React from 'react';
import fetchMovieListByType from '../lib/utils';
import MovieList from '../components/MovieList';
class PageA extends React.Component {
    state = {
        movieList: [],
    }
    /* ... */
    async componentDidMount() {
        const movieList = await fetchMovieListByType('comedy');
        this.setState({
            movieList,
        });
    }
    
    render() {
        return <MovieList data={this.state.movieList} emptyTips="暂⽆喜剧"/>
    }
}
export default PageA;
// views/PageB.js
import React from 'react';
import fetchMovieListByType from '../lib/utils';
import MovieList from '../components/MovieList';
class PageB extends React.Component {
    state = {
        movieList: [],
    }
    // ...
    async componentDidMount() {
        const movieList = await fetchMovieListByType('action');
        this.setState({
            movieList,
        });
    }
    render() {
        return <MovieList data={this.state.movieList} emptyTips="暂⽆动作⽚"/>
    }
}
export default PageB;
```

```jsx
// 冗余代码过多
// HOC
import React from 'react';
const withFetchingHOC = (WrappedComponent, fetchingMethod, defaultProps)
=> {
    return class extends React.Component {
        async componentDidMount() {
            const data = await fetchingMethod();
            this.setState({
                data,
            });
        }
        
        render() {
            return (
                <WrappedComponent
                data={this.state.data}
                {...defaultProps}
                {...this.props}
                />
            );
        }
    }
}
// 使⽤：
// views/PageA.js
import React from 'react';
import withFetchingHOC from '../hoc/withFetchingHOC';
import fetchMovieListByType from '../lib/utils';
import MovieList from '../components/MovieList';
const defaultProps = {emptyTips: '暂⽆喜剧'}
export default withFetchingHOC(MovieList,
fetchMovieListByType('comedy'), defaultProps);
// views/PageB.js
import React from 'react';
import withFetchingHOC from '../hoc/withFetchingHOC';
import fetchMovieListByType from '../lib/utils';
import MovieList from '../components/MovieList';
const defaultProps = {emptyTips: '暂⽆动作⽚'}

export default withFetchingHOC(MovieList,
fetchMovieListByType('action'), defaultProps);;
// views/PageOthers.js
import React from 'react';
import withFetchingHOC from '../hoc/withFetchingHOC';
import fetchMovieListByType from '../lib/utils';
import MovieList from '../components/MovieList';
const defaultProps = {...}
export default withFetchingHOC(MovieList, fetchMovieListByType('someother-type'), defaultProps);
```

更符合 ⾥⽒代换原则(Liskov Substitution Principle LSP)，任何基类可以出现的地⽅，⼦类⼀定可以出现。LSP是继承复⽤的基⽯，只有当衍⽣类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复⽤，⽽衍⽣类也能够在基类的基础上增加新的⾏为
- 权限控制（属性代理）

```jsx
import React from 'react';
import { whiteListAuth } from '../lib/utils'; // 鉴权⽅法
function AuthWrapper(WrappedComponent) {
  return class AuthWrappedComponent extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            permissionDenied: -1,
        };
    }
    
    async componentDidMount() {
        try {
            await whiteListAuth(); // 请求鉴权接⼝
            this.setState({
                permissionDenied: 0,
            });
        } catch (err) {
            this.setState({
                permissionDenied: 1,
            });
        }
    }
    
    render() {
        if (this.state.permissionDenied === -1) {
            return null; // 鉴权接⼝请求未完成
        }
        if (this.state.permissionDenied) {
            return <div>功能即将上线，敬请期待~</div>;
        }
        return <WrappedComponent {...this.props} />;
    }
 }
}
export default AuthWrapper;
```

- 组件渲染性能(反向继承)
如何计算⼀个组件render期间的渲染耗时？

```jsx
import React from 'react';
// Home 组件
class Home extends React.Component {
    render () {
        return (<h1>Hello World.</h1>);
    }
}
// HOC
function withTiming (WrappedComponent) {
  let start, end;
  return class extends WrappedComponent {
    constructor (props) {
        super(props);
        start = 0;
        end = 0;
    }
    componentWillMount () {
        if (super.componentWillMount) {
            super.componentWillMount();
        }
        start = +Date.now();
    }
    componentDidMount () {
        if (super.componentDidMount) {
            super.componentDidMount();
        }
        end = +Date.now();
        console.error(`${WrappedComponent.name} 组件渲染时间为 ${end - start}ms`);
    }
    render () {
      return super.render();
    }
  };
}
export default withTiming(Home);
```

## Hook详解

为什么要使⽤Hooks？
1. 开发友好，可扩展性强，抽离公共的⽅法或组件，Hook 使你在⽆需修改组件结构的情况下复⽤状态逻辑；
2. 函数式编程，将组件中相互关联的部分根据业务逻辑拆分成更⼩的函数；
3. class更多作为语法糖，没有稳定的提案，且在开发过程中会出现不必要的优化点，Hooks⽆需学习复杂的函数式或响应式编程技术；

### 常见Hooks

### useState

```js
const [number, setNumber] = useState(0);
```

1. setState⽀持stateless组件有⾃⼰的state；
2. ⼊参：具体值或⼀个函数；
3. 返回值：数组，第⼀项是state值，第⼆项负责派发数据更新，组件渲染；

注意：setState会让组件重新执⾏，所以⼀般需要配合useMemo或useCallback；

```jsx
const DemoState = (props) => {
   /* number为此时state读取值 ，setNumber为派发更新的函数 */
   const [number, setNumber] = useState(0) /* 0为初始值 */
   return (
     <div>
       <span>{ number }</span>
       <button onClick={ ()=> {
         setNumber(number + 1)
         console.log(number) /* 这⾥的number是不能够即使改变的，返回0 */
         }}
        />
     </div>
   )
}
// 当更新函数之后，state的值是不能即时改变的，只有当下⼀次上下⽂执⾏的时候，state值才随之改变
——————————————————————————————————————————
const a =1
const DemoState = (props) => {
   /* useState 第⼀个参数如果是函数 则处理复杂的逻辑，返回值为初始值 */
   let [number, setNumber] = useState(()=>{
      // number
      return a === 1 ? 1 : 2
   }) /* 1为初始值 */
   return (<div>
       <span>{ number }</span>
       <button onClick={ ()=>setNumber(number+1) } ></button>
   </div>)
}
```

### useEffect

1. 使⽤条件：当组件init、dom render完成、操纵dom、请求数据（如componentDidMount）等；
2. 不限制条件，组件每次更新都会触发useEffect --> componentDidUpdate 与 componentwillreceiveprops；
3. useEffect 第⼀个参数为处理事件，第⼆个参数接收数组，为限定条件，当数组变化时触发事件，为[]只在组件初始化时触发；
4. useEffect第⼀个参数有返回时，⼀般⽤来消除副作⽤（如去除定时器、事件绑定等）；

```jsx
/* 模拟数据交互 */
function getUserInfo(a)
    return new Promise((resolve)=>{
        setTimeout(()=>{
            resolve({
                name:a,
                age:16,
            })
        },500)
    })
}
const Demo = ({ a }) => {
  const [ userMessage , setUserMessage ] = useState({})
  const [number, setNumber] = useState(0)
  
  const div= useRef()
  
  const handleResize =()=>{}
    useEffect(()=>{
        getUserInfo(a).then(res=>{
            setUserMessage(res)
        })
        console.log(div.current) /* div */
        window.addEventListener('resize', handleResize)
    /*
        只有当props->a和state->number改变的时候 ,useEffect副作⽤函数重新执⾏ ，
        如果此时数组为空[]，证明函数只有在初始化的时候执⾏⼀次相当于componentDidMount
    */
    },[ a ,number ])
    return (<div ref={div} >
        <span>{ userMessage.name }</span>
        <span>{ userMessage.age }</span>
        <div onClick={ ()=> setNumber(1) } >{ number }</div>
    </div>)
}

const Demo = ({ a }) => {
    const handleResize =()=>{}
    useEffect(()=>{
        const timer = setInterval(()=>console.log(666),1000)
        window.addEventListener('resize', handleResize)
        
        /* 此函数⽤于清除副作⽤ */
        return function(){
            clearInterval(timer)
            window.removeEventListener('resize', handleResize)
        }
    },[ a ])
    return (<div></div>)
}
```

注意：useEffect⽆法直接使⽤async await，

```jsx
// Bad
useEffect(async ()=>{
  /* 请求数据 */
  const res = await getUserInfo(payload)
},[ a ,number ])
————————————————————————————————————————————————
useEffect(() => {
  // declare the async data fetching function
  const fetchData = async () => {
    const data = await fetch('https://xxx.com');
    const json = await data.json();
    return json;
 }
  // call the function
  const result = fetchData()
   .catch(console.error);
  // ❌ ⽆效
  setData(result);
}, [])
// 改进版
useEffect(() => {
  const fetchData = async () => {
    const data = await fetch('https://xxx.com');
    const json = await response.json();
    setData(json);
 }
  // call the function
  fetchData()
    // make sure to catch any error
   .catch(console.error);;
}, [])
```

### useLayoutEffect

渲染更新之前的 useEffect
useEffect： 组件更新挂载完成 -> 浏览器dom 绘制完成 -> 执⾏useEffect回调 ；

useLayoutEffect ： 组件更新挂载完成 -> 执⾏useLayoutEffect回调-> 浏览器dom 绘制完成；

渲染组件
1. useEffect：闪动；
2. useLayoutEffect：卡顿；

```jsx
const DemoUseLayoutEffect = () => {
    const target = useRef()
    useLayoutEffect(() => {
        /*我们需要在dom绘制之前，移动dom到制定位置*/
        const { x ,y } = getPositon() /* 获取要移动的 x,y坐标 */
        animate(target.current,{ x,y })
    }, []);
    return (
        <div >
            <span ref={ target } className="animate"></span>
        </div>
    )
}
```

### useRef

⽤来获取元素、缓存数据；
⼊参可以作为初始值

```jsx
// 获取元素
const DemoUseRef = ()=>{
    const dom= useRef(null)
    const handerSubmit = ()=>{
        /* <div >表单组件</div> dom 节点 */
        console.log(dom.current)
    }
    return <div>
        <div ref={dom} >表单组件</div>
        <button onClick={()=>handerSubmit()} >提交</button>
    </div>
}
// 缓存数据，⼩技巧
// 不同于useState，useRef改变值不会使comp re-render
const currenRef = useRef(InitialData)
currenRef.current = newValue
```

### useContext

⽤来获取⽗级组件传递过来的context值，这个当前值就是最近的⽗级组件 Provider 的value；从parent comp获取ctx⽅式；

1. useContext(Context)；
2. Context.Consumer

```jsx
/* ⽤useContext⽅式 */
const DemoContext = ()=> {
  const value = useContext(Context);
  /* my name is aaa */
  return <div> my name is { value.name }</div>
}
/* ⽤Context.Consumer ⽅式 */
const DemoContext1 = ()=>{
  return <Context.Consumer>
   {/* my name is aaa */}
   { (value)=> <div> my name is { value.name }</div> }
  </Context.Consumer>
}
export default ()=>{
  return <div>
    <Context.Provider value={{ name:'aaa' }} >
      <DemoContext />
      <DemoContext1 />
    </Context.Provider>
  </div>
}
```

### useReducer

⼊参：
1. 第⼀个为函数，可以视为reducer，包括state 和 action，返回值为根据action的不同⽽改变后的state；
2. 第⼆个为state的初始值；

出参：
1. 第⼀个更新后的state值；
2. 第⼆个是派发更新的dispatch函数；执⾏dispatch会导致组件re-render；（另⼀个是useState）

```jsx
const DemoUseReducer = ()=>{
    /* number为更新后的state值, dispatchNumbner 为当前的派发函数 */
    const [ number , dispatchNumbner ] = useReducer((state, action) => {
        const { payload , name } = action
        /* return的值为新的state */
        switch(name) {
            case 'a':
                return state + 1
            case 'b':
                return state - 1
            case 'c':
            return payload      
        }
        return state
    }, 0)

    return <div>
        当前值：{ number }
        { /* 派发更新 */ }
        <button onClick={()=>dispatchNumbner({ name: 'a' })} >增加</button>
        <button onClick={()=>dispatchNumbner({ name: 'b' })} >减少</button>
        <button onClick={()=>dispatchNumbner({ name: 'c' , payload:666 })}>赋值</button>
        { /* 把dispatch 和 state 传递给⼦组件 */ }
        <MyChildren  dispatch={ dispatchNumbner } State={{ number }} />
    </div>
}
```

业务中经常将 useReducer+useContext 代替Redux

### useMemo

⽤来根据useMemo的第⼆个参数deps（数组）判定是否满⾜当前的限定条件来决定是否执⾏第⼀个cb；

```jsx
// selectList 不更新时，不会重新渲染，减少不必要的循环渲染
useMemo(() => (
  <div>{
    selectList.map((i, v) => (
      <span
        className={style.listSpan}
        key={v} >
       {i.patentName}
      </span>
   ))}
  </div>
), [selectList])
————————————————————————————————————————————————————
// listshow, cacheSelectList 不更新时，不会重新渲染⼦组件
useMemo(() => (
  <Modal
    width={'70%'}
    visible={listshow}
    footer={[
      <Button key="back" >取消</Button>,
      <Button
          key="submit"
          type="primary"
       >
          确定
      </Button>
   ]}
  >
   { /* 减少了PatentTable组件的渲染 */ }
    <PatentTable
      getList={getList}
      selectList={selectList}
      cacheSelectList={cacheSelectList}
      setCacheSelectList={setCacheSelectList}
    />
  </Modal>
 ), [listshow, cacheSelectList])
————————————————————————————————————————

// 减少组件更新导致函数重新声明
const DemoUseMemo = () => {
  /* ⽤useMemo 包裹之后的log函数可以避免了每次组件更新再重新声明 ，可以限制上下⽂的执⾏ */
    const newLog = useMemo(() => {
        const log = () => {
            console.log(123)
        }
        return log
    }, [])
    return <div onClick={()=> newLog() } ></div>
}

————————————————————————————————————————————————————
// 如果没有加相关的更新条件，是获取不到更新之后的state的值的
const DemoUseMemo = () => {
    const [ number ,setNumber ] = useState(0)
    const newLog = useMemo(() => {
            const log = () => {
            /* 点击span之后 打印出来的number 不是实时更新的number值 */
            console.log(number)
        }
            return log
            /* [] 没有 number */  
    }, [])
    return <div>
            <div onClick={() => newLog()} >打印</div>
            <span onClick={ () => setNumber( number + 1 ) } >增加</span>
        </div>
}

```

### useCallback

useMemo返回cb的运⾏结果；
useCallback返回cb的函数；

```jsx
import React, { useState, useCallback } from 'react'
function Button(props) {
    const { handleClick, children } = props;
    console.log('Button -> render');
    return (
        <button onClick={handleClick}>{children}</button>
    )
}
const MemoizedButton = React.memo(Button);
export default function Index() {
    const [clickCount, increaseCount] = useState(0);
    const handleClick = () => {
        console.log('handleClick');
        increaseCount(clickCount + 1);
    }
    return (
        <div>
            <p>{clickCount}</p>
            <MemoizedButton handleClick={handleClick}>Click</MemoizedButton>
        </div>
    )
}
// MemoizedButton还是重新渲染了
// Index组件state发⽣变化，导致组件重新渲染；
// 每次渲染导致重新创建内部函数handleClick ，
// 进⽽导致⼦组件Button也重新渲染。
import React, { useState, useCallback } from 'react'
function Button(props) {
    const { handleClick, children } = props;
    console.log('Button -> render');
    return (
        <button onClick={handleClick}>{children}</button>
    )
}
const MemoizedButton = React.memo(Button);

export default function Index() {
    const [clickCount, increaseCount] = useState(0);
    // 这⾥使⽤了`useCallback`
    const handleClick = useCallback(() => {
        console.log('handleClick');
        increaseCount(clickCount + 1);
    }, [])
    return (
        <div>
            <p>{clickCount}</p>
            <MemoizedButton handleClick={handleClick}>Click</MemoizedButton>
        </div>
    )
}
```

### Hooks实战

1. 所有依赖都必须放在依赖数组中么？
useEffect 中，默认有个共识： useEffect 中使⽤到外部变量，都应该放到第⼆个数组参数中。

```jsx
// 当props.count 和 count 变化时，上报数据
function Demo(props) {
    const [count, setCount] = useState(0);
    const [text, setText] = useState('');
    const [a, setA] = useState('');
    
    useEffect(() => {
        monitor(props.count, count, text, a);
    }, [props.count, count]);
    
    return (
        <div>
            <button
                onClick={() => setCount(count => count + 1)}
            >
                click
            </button>
            <input value={text} onChange={e => setText(e.target.value)} />
            <input value={a} onChange={e => setA(e.target.value)} />
        </div>
    )
}
```
此时，text 和 a 变量没有放在dps 数组中

如果把text 和 a 也引⼊deps中，当text 和 a改变时，也触发了函数执⾏

Solution：
1. 不要使⽤ eslint-plugin-react-hooks 插件，或者可以选择性忽略该插件的警告；
2. 只有⼀种情况，需要把变量放到 deps 数组中，那就是当该变量变化时，需要触发 useEffect 函数执⾏。⽽不是因为 useEffect 中⽤到了这个变量！

2. 尽量不要用useCallback

:::tip
1. useCallback ⼤部分场景没有提升性能
2. useCallback让代码可读性变差
::: 

```jsx
// Example 1
const someFunc = useCallback(()=> {
   doSomething();
}, []);
return <ExpensiveComponent func={someFunc} />
const ExpensiveComponent = ({ func }) => {
  return (
    <div onClick={func}>
     hello
    </div>
 )
}
// 必须⽤React.memo wrapper 住⼦组件，才能避免在参数不变的情况下，不重复渲染
// 所以⼀般项⽬中不建议使⽤useCallback
const ExpensiveComponent = React.memo(({ func }) => {
  return (
    <div onClick={func}>
     hello
    </div>
 )
}

// Example 2
const someFuncA = useCallback((d, g, x, y)=> {
   doSomething(a, b, c, d, g, x, y);
}, [a, b, c]);
const someFuncB = useCallback(()=> {
   someFuncA(d, g, x, y);
}, [someFuncA, d, g, x, y]);
useEffect(()=>{
  someFuncB();
}, [someFuncB]);
// 依赖层层传递，最终要找到哪些出发了useEffect执⾏，所以直接引⽤就好
const someFuncA = (d, g, x, y)=> {
   doSomething(a, b, c, d, g, x, y);
};
const someFuncB = ()=> {
   someFuncA(d, g, x, y);
};
useEffect(()=>{
  someFuncB();
}, [...]);
```

3. useMemo建议适当使⽤

在deps不变，且⾮简单的基础类型运算的情况下建议使⽤

```jsx
// 没有使⽤ useMemo
const memoizedValue = computeExpensiveValue(a, b);
// 使⽤ useMemo
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
// 如果没有使⽤ useMemo，computeExpensiveValue 会在每⼀次渲染的时候执⾏;
// 如果使⽤了 useMemo，只有在 a 和 b 变化时，才会执⾏⼀次
computeExpensiveValue。
const a = 1;
const b = 2;
const c = useMemo(()=> a + b, [a, b]);
const c = a + b; // 内存消耗少
```

4. useState的正确使⽤姿势

:::tip
1. 能⽤其他状态计算出来就不⽤单独声明状态。⼀个 state 必须不能通过其它 state/props 直接计算出来，否则就不⽤定义 state
2. 保证数据源唯⼀，在项⽬中同⼀个数据，保证只存储在⼀个地⽅
3. useState 适当合并
:::

```jsx
// Example 1
const SomeComponent = (props) => {
    const [source, setSource] = useState([
        {type: 'done', value: 1},
        {type: 'doing', value: 2},
    ])
    const [doneSource, setDoneSource] = useState([])
    const [doingSource, setDoingSource] = useState([])
    useEffect(() => {
        setDoingSource(source.filter(item => item.type === 'doing'))
        setDoneSource(source.filter(item => item.type === 'done'))
    }, [source])
    return (
        <div>
        .....
        </div>
    )
}
const SomeComponent = (props) => {
    const [source, setSource] = useState([
        {type: 'done', value: 1},
        {type: 'doing', value: 2},
    ])
    const doneSource = useMemo(()=> source.filter(item => item.type === 'done'), [source]);
    const doingSource = useMemo(()=> source.filter(item => item.type === 'doing'), [source]);
    return (
        <div>
        .....
        </div>
    )
}
// 避免props层层传递，在CR中很难看清楚

// Example 2
function SearchBox({ data }) {
    const [searchKey, setSearchKey] = useState(getQuery('key'));
    
    const handleSearchChange = e => {
        const key = e.target.value;
        setSearchKey(key);
        history.push(`/movie-list?key=${key}`);
    }
    
    return (
        <input
        value={searchKey}
        placeholder="Search..."
        onChange={handleSearchChange}
        />
    );
}

function SearchBox({ data }) {

    const searchKey = parse(localtion.search)?.key;
    const handleSearchChange = e => {
        const key = e.target.value;
        history.push(`/movie-list?key=${key}`);
    }
    return (
        <input
        value={searchKey}
        placeholder="Search..."
        onChange={handleSearchChange}
        />
    );
}
// url params 和 state重复了

// Example 3
const [firstName, setFirstName] = useState();
const [lastName, setLastName] = useState();
const [school, setSchool] = useState();
const [age, setAge] = useState();
const [address, setAddress] = useState();
const [weather, setWeather] = useState();
const [room, setRoom] = useState();
const [userInfo, setUserInfo] = useState({
  firstName,
  lastName,
  school,
  age,
  address
});
const [weather, setWeather] = useState();
const [room, setRoom] = useState();
// 更新⼀个时
setUserInfo(s=> ({
  ...s,
  fristName,
}))
```

### 自定义hooks

注意：⾃定义Hooks本质上还是实现⼀个函数，关键在于实现逻辑⼀般实现效果如：

```js
const [ a[, b, c...] ] = useXXX(arg1[, arg2, ...])
```

#### setTitle hook

```jsx
import { useEffect } from 'react'
const useTitle = (title) => {
    useEffect(() => {
        document.title = title
    }, [])
    return
}
export default useTitle

const App = () => {
    useTitle('new title')
    return <div>home</div>
}
```

#### update hook

```jsx
import { useState } from 'react'
const useUpdate = () => {
    const [, setFlag] = useState()
    const update = () => {
        setFlag(Date.now())
    }
    return update
}
export default useUpdate
// 实际使⽤
const App = (props) => {
    // ...
    const update = useUpdate()

    return 
    <div>
        {Date.now()}
        <div><button onClick={update}>update</button></div>
    </div>
}
```

#### useScroll hooks

```jsx
import { useState, useEffect } from 'react'
const useScroll = (scrollRef) => {
    const [pos, setPos] = useState([0,0])
    useEffect(() => {
        function handleScroll(e){
            setPos([scrollRef.current.scrollLeft, scrollRef.current.scrollTop])
        }
        scrollRef.current.addEventListener('scroll', handleScroll)
        return () => {
            scrollRef.current.removeEventListener('scroll', handleScroll)
        }
    }, [])
    
    return pos
}
export default useScroll
// ⽤法
import React, { useRef } from 'react'
import { useScroll } from 'hooks'
const Home = (props) => {
  const scrollRef = useRef(null)
  const [x, y] = useScroll(scrollRef)
  return <div>
      <div ref={scrollRef}>
        <div className="innerBox"></div>
      </div>
      <div>{ x }, { y }</div>
    </div>
}
```

### Hooks VS HOC

1. Hook最典型的就是取代掉⽣命周期中⼤多数的功能，可以把更相关的逻辑放在⼀起，⽽⾮零散在各个⽣命周期⽅法中；

2. ⾼阶组件可以将外部的属性功能到⼀个基础 Component 中，更多作为扩展能⼒的插件（如 reactswipeable-views中的 autoPlay ⾼阶组件，通过注⼊状态化的 props 的⽅式对组件进⾏功能扩展，⽽不是直接将代码写在主库中）；

3. Hook 的写法可以让代码更加紧凑，更适合做 Controller 或者需要内聚的相关逻辑，⼀般与⽬标组件内强依赖，HOC更强调对原先组件能⼒的扩展；
4. ⽬前 Hook 还处于相对早期阶段（React 16.8.0 才正式发布Hook 稳定版本），⼀些第三⽅的库可能还暂时⽆法兼容 Hook；


## 异步组件

随着项⽬的增⻓，代码包也会随之增⻓，尤其是在引⼊第三⽅的库的情况下，要避免因体积过⼤导致加载时间过⻓。

React16.6中，引⼊了 React.lazy 和 React.Suspense 两个API，再配合动态 import() 语法就可以实现组件代码打包分割和异步加载。

:::tip
传统模式：渲染组件-> 请求数据 -> 再渲染组件
异步模式：请求数据-> 渲染组件；
:::

```js
// demo
import React, { lazy, Suspense } from 'react';
// lazy 和 Suspense 配套使⽤，react原⽣⽀持代码分割
const About = lazy(() => import(/* webpackChunkName: "about"*/'./About'));
class App extends React.Component {
  render() {
    return (
      <div className="App">
        <h1>App</h1>
        <Suspense fallback={<div>loading</div>}>
          <About />
        </Suspense>
      </div>
   );
 }
}
export default App;
```

### 前置基础

1. 动态import

相对于静态import的 `import XX from XXX`，动态import指在运⾏时加载

```jsx
import('./test.js').then(test => {
    // ...
});
// 可⻅，是实现了Promsie规范的，回调函数为返回的模块
```

2. 错误边界

React V 16中引⼊，部分UI的JS错误不会导致整个应⽤崩溃；
错误边界是⼀种 React 组件，错误边界在 渲染期间、⽣命周期⽅法和整个组件树的构造函数 中捕获错误，且会渲染出备⽤UI⽽不是崩溃的组件。

```jsx
// comp ErrorBoundary
import React from 'react'
class ErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false };
    }
    static getDerivedStateFromError(error) {
        // 更新 state 使下⼀次渲染能够显示降级后的 UI
        return { hasError: true };
    }
    componentDidCatch(error, errorInfo) {
        // 你同样可以将错误⽇志上报给服务器
        console.log(error, errorInfo)
    }
    render() {
        if (this.state.hasError) {
            // 你可以⾃定义降级后的 UI 并渲染
            return <h1>Something went wrong.</h1>;
        }
        return this.props.children;
    }
}

export default ErrorBoundary
// comp App
import React, from 'react';
import ErrorBoundary from './ErrorBoundary'
class App extends React.Component {
    state = {
        count: 1
    }
    render() {
        const { count } = this.state
        if (count === 3) {
            throw new Error('I crashed!');
        }
        return (
            <ErrorBoundary>
                <h1>App</h1>
                <p>{count}</p>
                <button onClick={() => this.setState({ count: count + 1})}>add</button>
            </ErrorBoundary>
        )
    }
}
export default App;
```

### 手写异步组件

Suspense组件需要等待异步组件加载完成再渲染异步组件的内容。

1. lazy wrapper住异步组件，React第⼀次加载组件的时候，异步组件会发起请求，并且抛出异常，终⽌渲染；
2. Suspense⾥有componentDidCatch⽣命周期函数，异步组件抛出异常会触发这个函数，然后改变状态使其渲染fallback参数传⼊的组件；
3. 异步组件的请求成功返回之后，Suspense组件再次改变状态使其渲染正常⼦组件（即异步组件）；

```js
// comp About
const About = lazy(() => new Promise(resolve => {
    setTimeout(() => {
        resolve({
            default: <div>component content</div>
        })
    }, 1000)
}))

// comp Suspense
import React from 'react'
class Suspense extends React.PureComponent {
    /**
     * isRender 异步组件是否就绪，可以渲染
     */
    state = {
        isRender: true
    }
    componentDidCatch(e) {
        this.setState({ isRender: false })
        e.promise.then(() => {
            /* 数据请求后，渲染真实组件 */
            this.setState({ isRender: true })
        })
    }
    render() {
        const { fallback, children } = this.props
        const { isRender } = this.state
        return isRender ? children : fallback
    }
}
export default Suspense

// comp lazy
import React, { useEffect } from 'react'
export function lazy(fn) {
    const fetcher = {
        status: 'pending',
        result: null,
        promise: null,
    }
    return function MyComponent() {
        const getDataPromise = fn()
        fetcher.promise = getDataPromise
        getDataPromise.then(res => {
            fetcher.status = 'resolved'
            fetcher.result = res.default
        })
        useEffect(() => {
            if (fetcher.status === 'pending') {
                throw fetcher
            }
        }, [])
        if (fetcher.status === 'resolved') {
            return fetcher.result
        }
        return null
    }
}

// 实现的效果与React⽀持内容保持⼀致
import React, {Suspese, lazy} from 'react'
const About= lazy(() => { import('../About') });
class App extends React.Component {
  render() {
    /**
     * 1. 使⽤ React.Lazy 和 import() 来引⼊组件
     * 2. 使⽤<React.Suspense></React.Suspense>来做异步组件的⽗组件，并使⽤fallback 来实现组件未加载完成时展示信息
     * 3. fallback 可以传⼊html，也可以⾃⾏封装⼀个统⼀的提示组件
     */
    return (
      <div>
        <Suspense
          fallback={
            <Loading />
         }
        >
          <About />
        </Suspense>
      </div>
   )
 }
}
export default ReactComp;
```

## React18新特性

2021.11.15 React 18 升级到了beat版本，当前 17.0.2
发布节奏：
库的 Alpha 版本：当天可⽤
公开的 Beta 版：⾄少⼏个⽉
RC 版本：⾄少在 Beta 版发布后的⼏周
正式版：⾄少在 RC 版本发布之后的⼏周
主要改动包括：
1. Automatic batching（⾃动批量更新）
2. startTransition
3. ⽀持 React.lazy 的SSR架构
4. Concurrent Mode （并发渲染、可选）

### Automatic batching

:::tip
将多个状态更新合并成⼀个重新渲染以取得更好的性能的⼀种优化⽅式；
:::

- V18前

默认不batching的scene:
1. promise；
2. setTimeout；
3. 原⽣事件处理（native event handlers）；

```jsx
function App() {
    const [count, setCount] = useState(0);
    const [flag, setFlag] = useState(false);
    function handleClick() {
        setCount(c => c + 1); // Does not re-render yet
        setFlag(f => !f); // Does not re-render yet
        // React will only re-render once at the end (that's batching!)
    }
    return (
        <div>
            <button onClick={handleClick}>Next</button>
            <h1 style={{ color: flag ? "blue" : "black" }}>{count}</h1>
        </div>
    );
}
```

```jsx
function App() {
    const [count, setCount] = useState(0);
    const [flag, setFlag] = useState(false);
    function handleClick() {
        fetchSomething().then(() => {
        // React 17 and earlier does NOT batch these because
        // they run *after* the event in a callback, not *during* it
        setCount(c => c + 1); // Causes a re-render
        setFlag(f => !f); // Causes a re-render
    });
    }
    return (
        <div>
            <button onClick={handleClick}>Next</button>
            <h1 style={{ color: flag ? "blue" : "black" }}>{count}</h1>
        </div>
    );
}
```

- V18

所有更新⾃动batching

```jsx
function App() {
    const [count, setCount] = useState(0);
    const [flag, setFlag] = useState(false);
    function handleClick() {
        fetchSomething().then(() => {
            // React 18 and later DOES batch these:
            setCount(c => c + 1);
            setFlag(f => !f);
            // React will only re-render once at the end (that's batching!)
        });
    }
    return (
        <div>
            <button onClick={handleClick}>Next</button>
            <h1 style={{ color: flag ? "blue" : "black" }}>{count}</h1>
        </div>
    );
}
```

若不想batching？

```jsx
import { flushSync } from 'react-dom'; // Note: react-dom, not react
function handleClick() {
  flushSync(() => {
    setCounter(c => c + 1);
 });
  // React has updated the DOM by now
  flushSync(() => {
    setFlag(f => !f);
 });
  // React has updated the DOM by now
}
```

batching 对hooks及class的影响

```jsx
handleClick = () => {
    setTimeout(() => {
        this.setState(({ count }) => ({ count: count + 1 }));
        // V18前 { count: 1, flag: false }
        // V18中 { count: 0, flag: false }，除⾮使⽤flushSync
        console.log(this.state);
        this.setState(({ flag }) => ({ flag: !flag }));
    });
};
// 在⼀些react库中，如react-dom， unstable_batchedUpdates 实现类似功能
import { unstable_batchedUpdates } from 'react-dom';
unstable_batchedUpdates(() => {
  setCount(c => c + 1);
  setFlag(f => !f);
});
```

### startTransition

:::tip
可以让我们的⻚⾯在多数据更新⾥保持响应。这个API通过标记某些更新为"transitions"，来提⾼⽤户交互；
:::

实际：可以让我们的⻚⾯在展示时时刻保持re-render；
Example：我们更新input的value的同时⽤这个value去更新了⼀个有30000个item的list。然⽽这种多数据更新让⻚⾯⽆法及时响应，也让⽤户输⼊或者其他⽤户交互感觉很慢。
Solution：

```jsx
// 紧急的更新：展示⽤户的输⼊
setInputValue(e.target.value);
// ⾮紧急的更新： 展示结果
setContent(e.target.value)
```

V18前：update的优先级⼀样；
V18：⽀持优先级⼿动设置；

```jsx
import { startTransition } from 'react';
// Urgent: Show what was typed
setInputValue(input);
// Mark any state updates inside as transitions
startTransition(() => {
  // Transition: Show the results
  setSearchQuery(input);
});
// 等同于
先setInputValue(e.target.value) 后执⾏ setContent(e.target.value);
```

react中的upate：
Urgent updates：reflect direct interaction, like typing, clicking, pressing, and so on；
Transition updates：transition the UI from one view to another；

* 误区
1. 与setTimeout的区别
直接看起来结果类似：

```jsx
// debounce 和 throttle 经常使⽤
// Show what you typed
setInputValue(input);
// Show the results
setTimeout(() => {
  setSearchQuery(input);
}, 0);
```

区别：
a. startTransition不会被放到下⼀次event loop，是同步⽴即执⾏的，这也就意味着，⽐timeoutupdate更早，低端机体验明显;
使⽤场景
1. slow rendering：re-render需要耗费⼤量的⼯作量；
2. slow network：需要较⻓时间等待response的情况；

### ⽀持React.lazy的SSR架构

SSR场景
react的SSR（server side render）
1. server：获取数据；
2. server：组装返回带有HTML的接⼝；
3. client：加载 JavaScript；
4. client：hydration，将客户端的JS与服务端的HTML结合；
V18前：按序执⾏；
V18：⽀持拆解应⽤为独⽴单元，不影响其他模块；

SSR问题
1. server：获取数据； --> 按序执⾏，必须在服务端返回所有HTML；
2. client：加载 JavaScript； --> 必须JS加载完成；
3. client：hydration，将客户端的JS与服务端的HTML结合； --> hydrate后才能交互

流式 HTML&选择性hydrate
1. 流式HTML
2. client进⾏选择性的 hydration：\<Suspense\>

```js
<Layout>
  <NavBar />
  <Sidebar />
  <RightPane>
    <Post />
    <Suspense fallback={<Spinner />}> // 假设HTML加载很慢，分批
      <Comments />
    </Suspense>
  </RightPane>
</Layout>
————————————————————————————————————————————————
// HTML返回过来在加载
<div hidden id="comments">
  <!-- Comments -->
  <p>First comment</p>
  <p>Second comment</p>
</div>
<script>
  // This implementation is slightly simplified
  document.getElementById('sections-spinner').replaceChildren(
    document.getElementById('comments')
 );
</script>
```

1. js选择性加载

```jsx
import { lazy } from 'react';
const Comments = lazy(() => import('./Comments.js'));
// ...
<Suspense fallback={<Spinner />}>
  <Comments />
</Suspense>
```

2. hydration 之前要求交互

记录操作⾏为，并优先执⾏Urgent comp的hydration；

### Concurrent Mode（并发模式）

Concurrent Mode（以下简称CM）
什么是 CM 和 suspense？

在2019年 react conf提出了实验性的版本来⽀持CM 和 Suspense（可以理解为等待代码加载，且指定加载界⾯）
CM：
可帮助应⽤保持响应，并根据⽤户的设备性能和⽹速进⾏适当的调整。
阻塞渲染：如UI update，需要先执⾏对应视图操作，如更新DOM；
solution：
a. debounce：输⼊完成后响应，输⼊时不会更新；
b. throttle：功率低场景卡顿；
可中断渲染（CM）：
a. CPU-bound update： (例如创建新的 DOM 节点和运⾏组件中的代码)：中断当前渲染，切换
更⾼优先级；
b. IO-bound update： (例如从⽹络加载代码或数据)：response前先在内存进⾏渲染；
suspense
以声明的⽅式来“等待”任何内容，包括数据

```jsx
const resource = fetchProfileData();
function ProfilePage() {
  return (
    <Suspense fallback={<h1>Loading profile...</h1>}>
      <ProfileDetails />
      <Suspense fallback={<h1>Loading posts...</h1>}>
        <ProfileTimeline />
      </Suspense>
    </Suspense>
 );
}
function ProfileDetails() {
  // 尝试读取⽤户信息，尽管该数据可能尚未加载
  const user = resource.user.read();
  return <h1>{user.name}</h1>;
}
function ProfileTimeline() {
  // 尝试读取博⽂信息，尽管该部分数据可能尚未加载
  const posts = resource.posts.read();
  return (
    <ul>
     {posts.map(post => (
        <li key={post.id}>{post.text}</li>
     ))}
    </ul>
 );
}
```

*误区：Suspense 不是⼀个数据请求的库，⽽是⼀个机制。这个机制是⽤来给数据请求库向 React 通信说明某个组件正在读取的数据当前仍不可⽤
- 什么不是suspense
a. 不是数据获取⽅式；
b. 不是⼀个可以直接⽤于数据获取的客户端；
c. 它不使数据获取与视图层代码耦合；
- Suspense 可以做什么
a. 能让数据获取库与 React 紧密整合；
b. 能让你有针对性地安排加载状态的展示；
c. 能够消除 race conditions；


DEMO：
⽬前fetch data⽅式：
● Fetch-on-render（渲染之后获取数据，如：在 useEffect 中 fetch）

```jsx
// 在函数组件中：
useEffect(() => {
  fetchSomething();
}, []);
// 或者，在 class 组件⾥：
componentDidMount() {
  fetchSomething();
}
————————————————————————————————————————————————
function ProfilePage() {
    const [user, setUser] = useState(null);
    useEffect(() => {
        fetchUser().then(u => setUser(u));
    }, []);
    if (user === null) {
        return <p>Loading profile...</p>;
    }
    return (
        <>
            <h1>{user.name}</h1>
            <ProfileTimeline />
        </>
    );
}

function ProfileTimeline() {
    const [posts, setPosts] = useState(null);
    useEffect(() => {
        fetchPosts().then(p => setPosts(p));
    }, []);
    if (posts === null) {
        return <h2>Loading posts...</h2>;
    }
    return (
        <ul>
        {posts.map(post => (
            <li key={post.id}>{post.text}</li>
        ))}
        </ul>
    );
}
// 结果：只有在fetch user 后才会fetch post，请求被串⾏发出

```

● Fetch-then-render（接收到全部数据之后渲染，如：不使⽤ Suspense 的 Relay）

```jsx
function fetchProfileData() {
  return Promise.all([
    fetchUser(),
    fetchPosts()
 ]).then(([user, posts]) => {
    return {user, posts};
 })
}
————————————————————————————————————————————————
// 尽早开始获取数据
const promise = fetchProfileData();
function ProfilePage() {
    const [user, setUser] = useState(null);
    const [posts, setPosts] = useState(null);
    useEffect(() => {
        promise.then(data => {
            setUser(data.user);
            setPosts(data.posts);
        });
    }, []);
    if (user === null) {
        return <p>Loading profile...</p>;
    }
    return (
        <>
        <h1>{user.name}</h1>
        <ProfileTimeline posts={posts} />
        </>
    );
}

// ⼦组件不再触发数据请求
function ProfileTimeline({ posts }) {
    if (posts === null) {
        return <h2>Loading posts...</h2>;
    }
    return (
        <ul>
            {posts.map(post => (
                <li key={post.id}>{post.text}</li>
            ))}
        </ul>
    );
}
// fetch 完 user 和 post 后再render
```

● Render-as-you-fetch（获取数据之后渲染，如：使⽤了 Suspense 的 Relay）

同 Fetch-then-render 区别：
fetch-then-render：  开始获取数据 -> 结束获取数据 -> 开始渲染
render-as-you-fetch：开始获取数据 -> 开始渲染 -> 结束获取数据

```jsx
// 这不是⼀个 Promise。这是⼀个⽀持 Suspense 的特殊对象。
const resource = fetchProfileData();
function ProfilePage() {
  return (
    <Suspense fallback={<h1>Loading profile...</h1>}>
      <ProfileDetails />
      <Suspense fallback={<h1>Loading posts...</h1>}>
        <ProfileTimeline />
      </Suspense>
    </Suspense>
 );
}
function ProfileDetails() {
  // 尝试读取⽤户信息，尽管信息可能未加载完毕
  const user = resource.user.read();
  return <h1>{user.name}</h1>;
}
function ProfileTimeline() {
  // 尝试读取博⽂数据，尽管数据可能未加载完毕
  const posts = resource.posts.read();
  return (
    <ul>
     {posts.map(post => (
        <li key={post.id}>{post.text}</li>
     ))}
    </ul>
 );
}
// ⼀开始fetch data, 渲染 ProfileDetails 和 ProfileTimeline
// 依次渲染可渲染comp，没有可渲染comp，此时fallback，渲染h1
```

注意点：

- suspense要求尽早获取数据

```jsx
// ⼀早就开始数据获取，在渲染之前！
const resource = fetchProfileData();
// ...
function ProfileDetails() {
  // 尝试读取⽤户信息
  const user = resource.user.read();
  return <h1>{user.name}</h1>;
}
// 若⽆法保证在init时fetch data，⽽不是组件render后fetch data，可以根据props获取数据
// 开始获取数据，越快越好
const initialResource = fetchProfileData(0);
function App() {
    const [resource, setResource] = useState(initialResource);
    return (
        <>
        <button onClick={() => {
            const nextUserId = getNextId(resource.userId);
            // 再次获取数据：⽤户点击时
            setResource(fetchProfileData(nextUserId));
        }}>
            Next
        </button>
        <ProfilePage resource={resource} />
        </>
    );
}
```

- 如何解决race condition

```jsx
// useEffect race condition
function ProfilePage({ id }) {
    const [user, setUser] = useState(null);
    useEffect(() => {
        fetchUser(id).then(u => setUser(u));
    }, [id]);
    if (user === null) {
        return <p>Loading profile...</p>;
    }
    return (
        <>
        <h1>{user.name}</h1>
        <ProfileTimeline id={id} />
        </>
    );
}
function ProfileTimeline({ id }) {
    const [posts, setPosts] = useState(null);
    useEffect(() => {
        fetchPosts(id).then(p => setPosts(p));
    }, [id]);
    if (posts === null) {
        return <h2>Loading posts...</h2>;
    }
    return (
        <ul>
        {posts.map(post => (
            <li key={post.id}>{post.text}</li>
        ))}
        </ul>
    );
}
// race condition: 快速切换时，某个ProfileTimeline fetch 请求延时过⾼后，旧的response会覆盖新的state
————————————————————————————————————————————————
// suspense，开始获取数据 -> 开始渲染 -> 结束获取数据，获取完数据，⽴⻢setState
const initialResource = fetchProfileData(0);

function App() {
    const [resource, setResource] = useState(initialResource);
    return (
        <>
        <button onClick={() => {
            const nextUserId = getNextId(resource.userId);
            setResource(fetchProfileData(nextUserId));
        }}>
            Next
        </button>
        <ProfilePage resource={resource} />
        </>
    );
}
function ProfilePage({ resource }) {
    return (
        <Suspense fallback={<h1>Loading profile...</h1>}>
        <ProfileDetails resource={resource} />
        <Suspense fallback={<h1>Loading posts...</h1>}>
            <ProfileTimeline resource={resource} />
        </Suspense>
        </Suspense>
    );
}
function ProfileDetails({ resource }) {
    const user = resource.user.read();
    return <h1>{user.name}</h1>;
}
function ProfileTimeline({ resource }) {
    const posts = resource.posts.read();
    return (
        <ul>
        {posts.map(post => (
            <li key={post.id}>{post.text}</li>
        ))}
        </ul>
    );
}
// 原因：
// hooks⾥，setState需要在合理的时间设置；
// suspense⾥，获取完数据，⽴⻢setState
```