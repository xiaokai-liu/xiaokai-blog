const e=JSON.parse('{"key":"v-361db4f0","path":"/js/%E9%AB%98%E7%BA%A7/4.html","title":"前端模块化","lang":"zh-CN","frontmatter":{"date":"2022-04-01T00:00:00.000Z","category":["js高级"],"tag":["模块化"],"description":"前端模块化 模块化解决的问题主要有三个： 外部模块的管理 内部模块的组织 模块源码到目标代码的编译和转换 模块 将一个复杂的程序依据一定的规则封装成几个块，并进行组合在一起 块的内部数据与实现是私有的，只是向外暴露一些接口与外部其它模块进行通信 模块化的进化过程 全局function模式 将不同的功能封装成不同的全局函数 编码：将不同的功能封装成不同的全局函数 问题：污染全局命名空间, 容易引起命名冲突或数据不安全，⽽且模块成员之间看不出直接关系","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/js/%E9%AB%98%E7%BA%A7/4.html"}],["meta",{"property":"og:title","content":"前端模块化"}],["meta",{"property":"og:description","content":"前端模块化 模块化解决的问题主要有三个： 外部模块的管理 内部模块的组织 模块源码到目标代码的编译和转换 模块 将一个复杂的程序依据一定的规则封装成几个块，并进行组合在一起 块的内部数据与实现是私有的，只是向外暴露一些接口与外部其它模块进行通信 模块化的进化过程 全局function模式 将不同的功能封装成不同的全局函数 编码：将不同的功能封装成不同的全局函数 问题：污染全局命名空间, 容易引起命名冲突或数据不安全，⽽且模块成员之间看不出直接关系"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-09T10:07:13.000Z"}],["meta",{"property":"article:author","content":"xiaokai"}],["meta",{"property":"article:tag","content":"模块化"}],["meta",{"property":"article:published_time","content":"2022-04-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-09T10:07:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"前端模块化\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-01T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-09T10:07:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xiaokai\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"模块","slug":"模块","link":"#模块","children":[]},{"level":2,"title":"模块化的进化过程","slug":"模块化的进化过程","link":"#模块化的进化过程","children":[{"level":3,"title":"全局function模式","slug":"全局function模式","link":"#全局function模式","children":[]},{"level":3,"title":"namespace模式","slug":"namespace模式","link":"#namespace模式","children":[]},{"level":3,"title":"IIFE模式","slug":"iife模式","link":"#iife模式","children":[]},{"level":3,"title":"IIFE模式增强","slug":"iife模式增强","link":"#iife模式增强","children":[]}]},{"level":2,"title":"模块化的好处","slug":"模块化的好处","link":"#模块化的好处","children":[]},{"level":2,"title":"引入多个<script>后出现的问题","slug":"引入多个-script-后出现的问题","link":"#引入多个-script-后出现的问题","children":[]},{"level":2,"title":"模块化规范","slug":"模块化规范","link":"#模块化规范","children":[{"level":3,"title":"CommonJS","slug":"commonjs","link":"#commonjs","children":[]},{"level":3,"title":"AMD","slug":"amd","link":"#amd","children":[]},{"level":3,"title":"CMD","slug":"cmd","link":"#cmd","children":[]},{"level":3,"title":"AMD与CMD的区别","slug":"amd与cmd的区别","link":"#amd与cmd的区别","children":[]},{"level":3,"title":"ES6模块化","slug":"es6模块化","link":"#es6模块化","children":[]},{"level":3,"title":"UMD","slug":"umd","link":"#umd","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"git":{"createdTime":1696846033000,"updatedTime":1696846033000,"contributors":[{"name":"xiaokai-liu","email":"1404197328@qq.com","commits":1}]},"readingTime":{"minutes":12.91,"words":3874},"filePathRelative":"js/高级/4.md","localizedDate":"2022年4月1日","excerpt":"<h1> 前端模块化</h1>\\n<p>模块化解决的问题主要有三个：</p>\\n<ul>\\n<li>外部模块的管理</li>\\n<li>内部模块的组织</li>\\n<li>模块源码到目标代码的编译和转换</li>\\n</ul>\\n<h2> 模块</h2>\\n<ul>\\n<li>将一个复杂的程序依据一定的规则封装成几个块，并进行组合在一起</li>\\n<li>块的内部数据与实现是私有的，只是向外暴露一些接口与外部其它模块进行通信</li>\\n</ul>\\n<h2> 模块化的进化过程</h2>\\n<h3> 全局function模式</h3>\\n<p>将不同的功能封装成不同的全局函数</p>\\n<ul>\\n<li>编码：将不同的功能封装成不同的全局函数</li>\\n<li>问题：污染全局命名空间, 容易引起命名冲突或数据不安全，⽽且模块成员之间看不出直接关系</li>\\n</ul>","autoDesc":true}');export{e as data};
